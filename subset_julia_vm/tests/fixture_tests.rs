//! Fixture-based tests for SubsetJuliaVM
//!
//! These tests load Julia code from .jl files and verify that SubsetJuliaVM
//! produces the same results as specified in manifest.toml files.
//!
//! The same .jl files can be run with:
//! - `cargo test` (this file)
//! - `julia scripts/run_julia_tests.jl`
//! - `sjulia` CLI
//!
//! Individual tests are auto-generated by build.rs from manifest.toml files.
//! Supports both:
//! - Single root manifest.toml (legacy mode)
//! - Distributed manifest.toml files in each category directory

use serde::Deserialize;
use std::fs;
use std::path::PathBuf;
use subset_julia_vm::{compile_and_run_value, vm::Value};

/// Root manifest structure (contains global config and optionally tests)
#[derive(Debug, Deserialize)]
struct RootManifest {
    config: Config,
    #[serde(default)]
    tests: Vec<TestCase>,
}

/// Category manifest structure (tests only, no config)
#[derive(Debug, Deserialize)]
struct CategoryManifest {
    #[serde(default)]
    tests: Vec<TestCase>,
}

/// Combined manifest for runtime use
#[derive(Debug)]
struct Manifest {
    config: Config,
    tests: Vec<TestCase>,
}

#[derive(Debug, Deserialize)]
struct Config {
    epsilon: f64,
}

/// Expected value can be a boolean, integer, float, or string
#[derive(Debug, Clone, Deserialize)]
#[serde(untagged)]
enum Expected {
    Bool(bool),     // Try bool first (most specific - only true/false)
    Int(i64),       // Try int next (integers without decimal)
    Float(f64),     // Try float next (any number with decimal)
    String(String), // Try string last
}

impl Expected {
    /// Check if the actual Value matches the expected value
    fn matches(&self, value: &Value, epsilon: f64) -> bool {
        match (self, value) {
            // Exact type matches
            (Expected::Bool(expected), Value::Bool(actual)) => expected == actual,
            (Expected::Int(expected), Value::I64(actual)) => expected == actual,
            (Expected::Float(expected), Value::F64(actual)) => (expected - actual).abs() < epsilon,
            (Expected::Float(expected), Value::I64(actual)) => {
                (expected - (*actual as f64)).abs() < epsilon
            }
            (Expected::String(expected), Value::Str(actual)) => expected == actual,
            // Cross-type matches for backwards compatibility
            (Expected::Bool(true), Value::I64(1)) => true,
            (Expected::Bool(false), Value::I64(0)) => true,
            // Float 1.0/0.0 can match Bool (legacy tests)
            (Expected::Float(f), Value::Bool(true)) if (*f - 1.0).abs() < epsilon => true,
            (Expected::Float(f), Value::Bool(false)) if f.abs() < epsilon => true,
            _ => false,
        }
    }

    fn display(&self) -> String {
        match self {
            Expected::Bool(b) => format!("{}", b),
            Expected::Int(i) => format!("{}", i),
            Expected::Float(f) => format!("{}", f),
            Expected::String(s) => format!("\"{}\"", s),
        }
    }
}

#[derive(Debug, Deserialize)]
struct TestCase {
    name: String,
    file: String,
    expected: Expected,
    #[serde(default)]
    description: String,
    #[serde(default)]
    skip: bool,
}

fn get_fixtures_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures")
}

fn load_manifest() -> Manifest {
    let fixtures_dir = get_fixtures_dir();
    let mut all_tests = Vec::new();

    // 1. Load root manifest (required for config)
    let root_manifest_path = fixtures_dir.join("manifest.toml");
    let root_content = fs::read_to_string(&root_manifest_path)
        .unwrap_or_else(|e| panic!("Failed to read manifest.toml: {}", e));
    let root_manifest: RootManifest = toml::from_str(&root_content)
        .unwrap_or_else(|e| panic!("Failed to parse manifest.toml: {}", e));

    // Add tests from root manifest (legacy support)
    all_tests.extend(root_manifest.tests);

    // 2. Scan for category manifest.toml files
    if let Ok(entries) = fs::read_dir(&fixtures_dir) {
        for entry in entries.filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_dir() {
                let category_manifest_path = path.join("manifest.toml");
                if category_manifest_path.exists() {
                    let category_name = path
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("unknown");

                    if let Ok(content) = fs::read_to_string(&category_manifest_path) {
                        match toml::from_str::<CategoryManifest>(&content) {
                            Ok(category_manifest) => {
                                // Prefix file paths with category name
                                for mut test in category_manifest.tests {
                                    if !test.file.contains('/') {
                                        test.file = format!("{}/{}", category_name, test.file);
                                    }
                                    all_tests.push(test);
                                }
                            }
                            Err(e) => {
                                eprintln!(
                                    "Warning: Failed to parse {}: {}",
                                    category_manifest_path.display(),
                                    e
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    // Detect duplicate test names across categories.
    // `run_fixture_test` uses `iter().find()` which returns the first match,
    // so duplicate names would silently load the wrong file. Panic early with
    // a clear diagnostic. See Issue #3135.
    let mut seen = std::collections::HashMap::new();
    for test in &all_tests {
        if let Some(prev_file) = seen.insert(test.name.clone(), test.file.clone()) {
            panic!(
                "Duplicate fixture test name '{}' found in manifests:\n  \
                 first:  {}\n  second: {}\n\
                 Test names must be unique across all categories. \
                 Rename one of them (e.g. add a category prefix).",
                test.name, prev_file, test.file
            );
        }
    }

    Manifest {
        config: root_manifest.config,
        tests: all_tests,
    }
}

fn run_test_case(test: &TestCase, epsilon: f64) {
    let fixtures_dir = get_fixtures_dir();
    let file_path = fixtures_dir.join(&test.file);

    let source = fs::read_to_string(&file_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", test.file, e));

    let result = compile_and_run_value(&source, 0)
        .unwrap_or_else(|e| panic!("Test '{}' failed with error: {}", test.name, e));

    assert!(
        test.expected.matches(&result, epsilon),
        "Test '{}' failed:\n  File: {}\n  Expected: {}\n  Got: {:?}\n  Description: {}",
        test.name,
        test.file,
        test.expected.display(),
        result,
        test.description
    );
}

/// Minimum thread stack size for fixture tests (16 MB).
///
/// The standard library (prelude) compilation is recursive and the total stack
/// usage grows with each new Pure Julia module.  After adding genericmemory.jl
/// (Memory{T}), the compilation exceeds the default 8 MB test-thread limit.
/// Running all tests on a 16 MB stack provides sufficient headroom for current
/// and future standard-library growth.  See Issue #2766.
const FIXTURE_TEST_STACK_SIZE: usize = 16 * 1024 * 1024;

/// Run a single fixture test by name (used by generated tests)
fn run_fixture_test(name: &str) {
    let name = name.to_string();
    let result = std::thread::Builder::new()
        .stack_size(FIXTURE_TEST_STACK_SIZE)
        .spawn(move || {
            let manifest = load_manifest();
            let test = manifest
                .tests
                .iter()
                .find(|t| t.name == name)
                .unwrap_or_else(|| panic!("Test case '{}' not found in manifest", name));

            // Skip tests marked with skip = true
            if test.skip {
                eprintln!("Skipping test '{}': marked as skip in manifest", name);
                return;
            }

            run_test_case(test, manifest.config.epsilon);
        })
        .expect("Failed to spawn fixture test thread")
        .join();

    // Re-panic on the test thread if the spawned thread panicked
    if let Err(e) = result {
        std::panic::resume_unwind(e);
    }
}


// Include auto-generated test modules from build.rs
include!(concat!(env!("OUT_DIR"), "/fixture_tests_generated.rs"));
