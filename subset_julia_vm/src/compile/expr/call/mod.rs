//! Function call compilation.
//!
//! Handles compilation of:
//! - User-defined function calls with multiple dispatch
//! - Module-qualified calls (Module.func)
//! - Dynamic type constructor calls
//! - N-ary operator reduction
//!
//! # Callable Variable Dispatch Heuristics
//!
//! When a variable name is used as a function (e.g., `f(x, y)`), the compiler must
//! determine how to dispatch the call. This decision is made at compile-time based
//! on the variable's static type:
//!
//! | Variable Type      | Dispatch Method                    | Use Case                           |
//! |--------------------|------------------------------------|------------------------------------|
//! | `ValueType::DataType` | `compile_dynamic_type_call`     | `T = Float64; T(1)`                |
//! | `ValueType::Function` | `compile_function_variable_call`| `f::Function; f(x)`                |
//! | `ValueType::GlobalRef`| `compile_globalref_call`        | `ref = GlobalRef(...); ref(x)`     |
//! | `ValueType::Any`      | See heuristics below            | Untyped function parameters        |
//!
//! ## `ValueType::Any` Heuristics
//!
//! For untyped function parameters (type `Any`), we use argument count to guess intent:
//!
//! - **1 argument**: Use `compile_dynamic_type_call` → `CallTypeConstructor`
//!   - Rationale: Type constructors like `T(x)` typically take 1 argument
//!   - VM handles DataType, Function, and ComposedFunction at runtime
//!   - Example: `function convert(T, x); T(x); end`
//!
//! - **2+ arguments**: Use `compile_function_variable_call` → `CallFunctionVariable`
//!   - Rationale: Multi-argument calls are likely function invocations
//!   - Example: `caller(f, x, y) = f(x, y)` (Issue #1457)
//!
//! - **`__field_func_` prefix**: Always use `compile_function_variable_call`
//!   - Generated by lowering for `obj.method(args)` patterns
//!
//! ## Known Edge Cases
//!
//! 1. **Multi-argument type constructors**: `Complex(1, 2)` when passed dynamically
//!    would be treated as a function call, not a type constructor. This works because
//!    `CallFunctionVariable` will find the constructor method.
//!
//! 2. **Zero-argument calls**: `f()` with `Any`-typed `f` falls through to regular
//!    function lookup, which may fail. Consider adding explicit handling.
//!
//! ## Future Improvement: Unified Runtime Dispatch
//!
//! A cleaner approach would be a unified `CallCallable(arg_count)` instruction that
//! dispatches at runtime based on the value type. This would eliminate compile-time
//! heuristics but requires VM changes. See Issue #1551 for discussion.

mod dynamic;
mod module_call;
mod nary;

use crate::builtins::BuiltinId;
use crate::ir::core::{BuiltinOp, Expr};
use crate::types::JuliaType;
use crate::vm::{Instr, ValueType};

use crate::compile::inference::infer_function_return_type_v2_with_arg_types;
use crate::compile::{
    base_function_to_builtin_op, err, is_base_function,
    is_builtin_type_name, is_random_function, is_reducible_nary_operator,
    julia_type_to_value_type, parse_parametric_call, CResult, CompileError, CoreCompiler, TypeExpr,
};

/// Functions available in the Iterators module, forwarded to Pure Julia implementations.
/// Shared across all 4 Iterators forwarding blocks in compile_module_call and
/// compile_module_function_ref. When adding/removing entries, only this constant
/// needs to change. See Issue #2602.
pub(super) const ITERATORS_FUNCTIONS: &[&str] = &[
    "enumerate",
    "zip",
    "rest",
    "countfrom",
    "take",
    "drop",
    "takewhile",
    "dropwhile",
    "cycle",
    "repeated",
    "product",
    "flatten",
    "flatmap",
    "partition",
    "peel",
    "nth",
    "filter",
    "map",
    "reverse",
    "accumulate",
    "sum",
];

impl CoreCompiler<'_> {
    pub(in crate::compile) fn compile_call(
        &mut self,
        function: &str,
        args: &[Expr],
        kwargs: &[(String, Expr)],
        splat_mask: &[bool],
        kwargs_splat_mask: &[bool],
    ) -> CResult<ValueType> {
        // Check if any argument is splatted
        let has_splat = !splat_mask.is_empty() && splat_mask.iter().any(|&b| b);
        // Check if any kwarg is splatted
        let has_kwargs_splat =
            !kwargs_splat_mask.is_empty() && kwargs_splat_mask.iter().any(|&b| b);

        // If splat is used, we need to handle it specially at the end.
        //
        // Function resolution order for splat calls (Issue #1675, #3256):
        //   1. locals with ValueType::Function  → CallFunctionVariableWithSplat
        //   2. locals with ValueType::Any       → CallFunctionVariableWithSplat
        //   3. method_tables / builtins          → PushFunction + CallFunctionVariableWithSplat
        //
        // This order mirrors the non-splat path below and ensures HOF patterns
        // like `f(args...)` where `f` is a parameter are resolved before falling
        // back to the global method table. The VM's CallFunctionVariableWithSplat
        // handler expands Array, Tuple, and Range values at runtime.
        if has_splat {
            // Compile all arguments
            for arg in args {
                self.compile_expr(arg)?;
            }

            // Check if function is a local variable holding a Function
            // This handles: function apply_variadic(f, args...); f(args...); end
            // Issue #1657: Must check function variables BEFORE method_tables lookup
            if let Some(&ValueType::Function) = self.locals.get(function) {
                // Load the function variable onto stack
                self.emit(Instr::LoadAny(function.to_string()));
                // Emit the dynamic function call with splat instruction
                self.emit(Instr::CallFunctionVariableWithSplat(
                    args.len(),
                    splat_mask.to_vec(),
                ));
                return Ok(ValueType::Any);
            }

            // Also check for Any-typed variables that might be functions
            // This handles: function apply(f, args...); f(args...); end where f::Any
            if let Some(&ValueType::Any) = self.locals.get(function) {
                // Load the variable onto stack
                self.emit(Instr::LoadAny(function.to_string()));
                // Emit the dynamic function call with splat instruction
                self.emit(Instr::CallFunctionVariableWithSplat(
                    args.len(),
                    splat_mask.to_vec(),
                ));
                return Ok(ValueType::Any);
            }

            // Look up the function in method tables or builtins for runtime dispatch.
            // Use PushFunction + CallFunctionVariableWithSplat for correct overload selection
            // after splat expansion — the runtime handler dispatches based on actual arg types.
            // This fixes Issue #3256 where the first-method workaround picked the wrong overload.
            let is_known = self.method_tables.contains_key(function)
                || BuiltinId::from_name(function).is_some();
            if is_known {
                self.emit(Instr::PushFunction(function.to_string()));
                self.emit(Instr::CallFunctionVariableWithSplat(
                    args.len(),
                    splat_mask.to_vec(),
                ));
                return Ok(ValueType::Any);
            }
            return err(format!(
                "Cannot find function '{}' for splat call",
                function
            ));
        }

        // Check if function name is a variable holding a DataType (dynamic type constructor)
        // This handles patterns like: T = Float64; T(1) or function f(T, x); T(x); end
        if let Some(&ValueType::DataType) = self.locals.get(function) {
            return self.compile_dynamic_type_call(function, args);
        }

        // Check if function name is a local variable holding a Function
        // This handles patterns like: function setprecision(f::Function, ...); f(); end
        // The function variable should be called dynamically, not looked up in method tables
        if let Some(&ValueType::Function) = self.locals.get(function) {
            return self.compile_function_variable_call(function, args);
        }

        // Check if function name is a variable holding a GlobalRef (callable GlobalRef)
        // This handles patterns like: ref = GlobalRef(Base, :println); ref("hello")
        if let Some(&ValueType::GlobalRef) = self
            .locals
            .get(function)
            .or_else(|| self.shared_ctx.global_types.get(function))
        {
            return self.compile_globalref_call(function, args);
        }

        // Check if function name is a variable holding a struct instance (callable struct)
        // This handles patterns like: (::MyType)(args) = body; mc = MyType(); mc(args)
        // The VM will look up __callable_<TypeName> at runtime.
        if let Some(ValueType::Struct(_)) = self
            .locals
            .get(function)
            .or_else(|| self.shared_ctx.global_types.get(function))
        {
            return self.compile_function_variable_call(function, args);
        }

        // Also check for function parameters with type Any that might be DataTypes or Functions
        // This handles: function convert(T, x); T(x); end where T is passed as Float64
        // Also check global variables for callable types (ComposedFunction, Function)
        let var_type = self
            .locals
            .get(function)
            .or_else(|| self.shared_ctx.global_types.get(function));
        if let Some(&ValueType::Any) = var_type {
            // Check if this is a field function call (generated by lowering c.f(x) pattern)
            // These variables are named __field_func_N where N is the span offset
            if function.starts_with("__field_func_") {
                return self.compile_function_variable_call(function, args);
            }
            // For single argument: use dynamic type call (handles DataType, Function, ComposedFunction)
            // For multiple arguments: use function variable call (first-class functions)
            // Type constructors typically take 1 argument, so multi-arg calls are likely functions
            if args.len() == 1 {
                return self.compile_dynamic_type_call(function, args);
            } else {
                // Multi-argument call with Any-typed variable: treat as function call
                // This enables first-class functions: caller(f, x, y) = f(x, y)
                return self.compile_function_variable_call(function, args);
            }
        }

        // Handle built-in functions that should take precedence over user-defined functions.
        // These are implemented as builtins for performance and correctness.
        //
        // MIGRATION NOTE (Issue #2616): When removing a Rust builtin during Pure Julia migration,
        // check if it has explicit routing here. Routes that call `compile_builtin_call()` will
        // fail with "Unknown function" if the builtin handler is removed but the route remains.
        // See docs/vm/BUILTIN_REMOVAL.md Layer 3 for the full checklist.
        match function {
            // Core.tuple: create a tuple from arguments (Issue #2173)
            // tuple(a, b, c) is equivalent to (a, b, c)
            "tuple" => {
                for arg in args {
                    self.compile_expr(arg)?;
                }
                self.emit(Instr::NewTuple(args.len()));
                return Ok(ValueType::Tuple);
            }
            // Handle ! operator as function call (from macro-generated code)
            "!" => {
                if args.len() != 1 {
                    return err("! operator requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::NotBool);
                return Ok(ValueType::Bool);
            }
            // Julia-compliant indexing: getindex / setindex!
            "getindex" | "setindex!" => {
                return self.compile_builtin_call(function, args);
            }
            // reshape: compile-time routed to builtin (Issue #2693)
            "reshape" => {
                return self.compile_builtin_call(function, args);
            }
            // similar: only route to builtin when first arg is Array-like (Issue #2693, #2700)
            // The Pure Julia broadcast pipeline calls similar(::Broadcasted, ::Type) which
            // must NOT be intercepted by the builtin handler (which expects similar(array, n::I64)).
            "similar" => {
                if !args.is_empty() {
                    let first_type = self.infer_expr_type(&args[0]);
                    if matches!(first_type, ValueType::Array | ValueType::ArrayOf(_)) {
                        return self.compile_builtin_call(function, args);
                    }
                }
            }
            // Type conversion: big() - must be handled before method dispatch
            "big" => {
                return self.compile_builtin_call(function, args);
            }
            // Note: gcd, lcm, factorial now use Pure Julia (base/intfuncs.jl)
            // findall: HOF form findall(f, arr) must be handled before method dispatch
            // Single-arg findall(A) is handled by Pure Julia method in base/array.jl
            // findall(pattern, string) is handled by StringFindAll builtin (Issue #2013)
            "findall" => {
                if args.len() == 2 {
                    let is_func_ref = match &args[0] {
                        Expr::FunctionRef { .. } => true,
                        Expr::Var(name, _) => self.method_tables.contains_key(name),
                        _ => false,
                    };
                    if is_func_ref {
                        // findall(f, arr) - route to builtin HOF handler
                        return self.compile_builtin_call(function, args);
                    }
                    // findall(pattern, string) - string pattern searching (Issue #2013)
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.emit(Instr::CallBuiltin(BuiltinId::StringFindAll, 2));
                    return Ok(ValueType::Any);
                }
                // Single-arg findall(A) falls through to method dispatch
            }
            // findfirst/findlast: HOF form (f, arr) must be handled before method dispatch
            // Value-search form findfirst(value, arr) is handled by Pure Julia in base/array.jl
            // String-search form findfirst(pattern, s) is handled by Pure Julia (base/strings/search.jl)
            "findfirst" | "findlast" => {
                if args.len() == 2 {
                    let is_func_ref = match &args[0] {
                        Expr::FunctionRef { .. } => true,
                        Expr::Var(name, _) => self.method_tables.contains_key(name),
                        _ => false,
                    };
                    if is_func_ref {
                        // findfirst/findlast HOF form - route to builtin HOF handler
                        return self.compile_builtin_call(function, args);
                    }
                }
                // Value-search and string-search forms fall through to method dispatch (Pure Julia)
            }
            // findnext/findprev: All forms now handled by Pure Julia method dispatch
            // - Predicate form findnext(f, A, start) → base/array.jl
            // - String-search form findnext(pattern, s, i) → base/strings/search.jl
            "findnext" | "findprev" => {
                // Fall through to method dispatch (Pure Julia)
            }
            // first/last: 1-arg calls use builtin TupleFirst/TupleLast,
            // 2-arg calls first(arr, n)/last(arr, n) use Pure Julia (base/range.jl)
            "first" | "last" => {
                if args.len() == 1 {
                    return self.compile_builtin_call(function, args);
                }
                // Multi-arg form falls through to method dispatch
            }
            // count: HOF form count(f, arr) must be handled before method dispatch
            // count(pattern, string) for string pattern counting (Issue #2009)
            // Single-arg count(arr) is handled by Pure Julia method in base/reduce.jl
            "count" => {
                if args.len() == 2 {
                    let is_func_ref = match &args[0] {
                        Expr::FunctionRef { .. } => true,
                        Expr::Var(name, _) => self.method_tables.contains_key(name),
                        _ => false,
                    };
                    if is_func_ref {
                        // Check if second argument is a string — if so, fall through
                        // to Pure Julia count(f::Function, s::String) (Issue #2081)
                        let arg_type = self.infer_expr_type(&args[1]);
                        if arg_type != ValueType::Str {
                            // count(f, arr) - route to builtin HOF handler
                            return self.compile_builtin_call(function, args);
                        }
                        // count(f, s::String) falls through to method dispatch
                    } else {
                        // count(pattern, string) - string pattern counting (Issue #2009)
                        self.compile_expr(&args[0])?;
                        self.compile_expr(&args[1])?;
                        self.emit(Instr::CallBuiltin(BuiltinId::StringCount, 2));
                        return Ok(ValueType::I64);
                    }
                }
                // Single-arg count(arr) or count(f, string) falls through to method dispatch
            }
            // sum/any/all: HOF form (f, arr) must be handled before method dispatch
            // Single-arg forms are handled by Pure Julia methods in base/array.jl or base/functional.jl
            "sum" | "any" | "all" => {
                if args.len() == 2 {
                    let is_func_ref = match &args[0] {
                        Expr::FunctionRef { .. } => true,
                        Expr::Var(name, _) => self.method_tables.contains_key(name),
                        _ => false,
                    };
                    if is_func_ref {
                        // sum/any/all HOF form - route to builtin HOF handler
                        return self.compile_builtin_call(function, args);
                    }
                }
                // Single-arg form falls through to method dispatch
            }
            // Dict mutating functions: empty!, merge!, get! - use builtin when argument is Dict
            // These have Julia methods for Array, but Dict needs the Rust builtin
            // Issue #2134: Must use LoadDict/StoreDict for in-place semantics
            "empty!" => {
                if args.len() != 1 {
                    return err("empty! requires exactly 1 argument: empty!(collection)");
                }
                // Infer argument type to decide dispatch
                let arg_type = self.infer_julia_type(&args[0]);
                if matches!(arg_type, JuliaType::Dict) {
                    if let Expr::Var(name, _) = &args[0] {
                        self.emit(Instr::LoadDict(name.clone()));
                        self.emit(Instr::CallBuiltin(BuiltinId::DictEmpty, 1));
                        self.emit(Instr::StoreDict(name.clone()));
                        self.emit(Instr::LoadDict(name.clone()));
                    } else {
                        self.compile_expr(&args[0])?;
                        self.emit(Instr::CallBuiltin(BuiltinId::DictEmpty, 1));
                    }
                    return Ok(ValueType::Dict);
                }
                // Fall through to method dispatch for Array and other types
            }
            "merge!" => {
                if args.len() != 2 {
                    return err("merge! requires exactly 2 arguments: merge!(d1, d2)");
                }
                // Infer argument type to decide dispatch
                let arg_type = self.infer_julia_type(&args[0]);
                if matches!(arg_type, JuliaType::Dict) {
                    if let Expr::Var(name, _) = &args[0] {
                        self.emit(Instr::LoadDict(name.clone()));
                        self.compile_expr(&args[1])?;
                        self.emit(Instr::CallBuiltin(BuiltinId::DictMergeBang, 2));
                        self.emit(Instr::StoreDict(name.clone()));
                        self.emit(Instr::LoadDict(name.clone()));
                    } else {
                        self.compile_expr(&args[0])?;
                        self.compile_expr(&args[1])?;
                        self.emit(Instr::CallBuiltin(BuiltinId::DictMergeBang, 2));
                    }
                    return Ok(ValueType::Dict);
                }
                // Fall through to method dispatch for other types
            }
            "get!" => {
                if args.len() != 3 {
                    return err("get! requires exactly 3 arguments: get!(dict, key, default)");
                }
                // get! is only for Dict - route to builtin
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.compile_expr(&args[2])?;
                self.emit(Instr::CallBuiltin(BuiltinId::DictGetBang, 3));
                return Ok(ValueType::Any);
            }
            // occursin: Regex case uses builtin, String case uses Pure Julia (Issue #2563)
            "occursin" => {
                if args.len() == 2 {
                    let first_arg_type = self.infer_expr_type(&args[0]);
                    if first_arg_type == ValueType::Regex {
                        // Regex occursin requires Rust builtin
                        self.compile_expr(&args[0])?;
                        self.compile_expr(&args[1])?;
                        self.emit(Instr::CallBuiltin(BuiltinId::Occursin, 2));
                        return Ok(ValueType::Bool);
                    }
                }
                // String or curried form: fall through to Pure Julia method dispatch
            }
            "match" => {
                if args.len() != 2 {
                    return err("match requires exactly 2 arguments: match(regex, string)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::RegexMatch, 2));
                return Ok(ValueType::Any); // Returns RegexMatch or Nothing
            }
            "eachmatch" => {
                if args.len() != 2 {
                    return err("eachmatch requires exactly 2 arguments: eachmatch(regex, string)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::RegexEachmatch, 2));
                return Ok(ValueType::Array); // Returns Array of RegexMatch
            }
            // Matrix inverse: type-dispatched (Array → faer builtin, Rational → Pure Julia)
            // We check argument type at compile time to route to the correct implementation
            "inv" => {
                if args.len() != 1 {
                    return err("inv requires exactly 1 argument: inv(A)");
                }
                // Infer argument type to decide dispatch
                let arg_type = self.infer_julia_type(&args[0]);
                // If the argument is an Array-like type (Array, VectorOf, MatrixOf),
                // use the faer-based builtin for matrix inverse
                let is_array_type = matches!(
                    arg_type,
                    JuliaType::Array
                        | JuliaType::VectorOf(_)
                        | JuliaType::MatrixOf(_)
                        | JuliaType::AbstractArray
                );
                if is_array_type {
                    self.compile_expr(&args[0])?;
                    self.emit(Instr::CallBuiltin(BuiltinId::Inv, 1));
                    return Ok(ValueType::Array);
                }
                // Otherwise (Rational, or unknown type), fall through to method dispatch
                // which will find inv(::Rational{T}) in Pure Julia
            }
            // Left division (backslash): A \ b solves Ax = b for x
            // Uses faer LU solve for matrix/vector operations
            "\\" => {
                if args.len() != 2 {
                    return err("\\ requires exactly 2 arguments: A \\ b");
                }
                // Infer first argument type to decide dispatch
                let arg_type = self.infer_julia_type(&args[0]);
                // If the first argument is an Array-like type, use the faer-based builtin
                let is_array_type = matches!(
                    arg_type,
                    JuliaType::Array
                        | JuliaType::VectorOf(_)
                        | JuliaType::MatrixOf(_)
                        | JuliaType::AbstractArray
                );
                if is_array_type {
                    self.compile_expr(&args[0])?;
                    self.compile_expr(&args[1])?;
                    self.emit(Instr::CallBuiltin(BuiltinId::Ldiv, 2));
                    return Ok(ValueType::Array);
                }
                // For scalars, \ is just division (a \ b = b / a)
                // Fall through to method dispatch or handle as scalar division
                self.compile_expr(&args[1])?;
                self.compile_expr(&args[0])?;
                self.emit(Instr::DivF64);
                return Ok(ValueType::F64);
            }
            // Note: LinearAlgebra functions (svd, qr, eigen, eigvals, cholesky, rank, cond)
            // are not handled here as direct builtins. They require `using LinearAlgebra`
            // to be loaded first, and will be handled via method dispatch or through
            // Base.LinearAlgebra.function_name resolution.
            // Note: real, imag, conj, abs, abs2 are now handled by Pure Julia with runtime type checking
            // Note: isequal is now Pure Julia (operators.jl + missing.jl, Issue #2718)
            // Note: isless is now Pure Julia (operators.jl + missing.jl, Issue #2712)
            "hash" => {
                // hash(x) - 1-arg: direct Rust builtin for performance
                // hash(x, h) - 2-arg: fall through to Pure Julia dispatch (hashing.jl)
                if args.len() == 1 {
                    self.compile_expr(&args[0])?;
                    self.emit(Instr::CallBuiltin(BuiltinId::Hash, 1));
                    return Ok(ValueType::I64);
                }
                // 2-arg hash(x, h) falls through to function dispatch
            }
            "convert" => {
                // convert(T, x) - convert x to type T
                if args.len() != 2 {
                    return err("convert requires exactly 2 arguments: convert(T, x)");
                }
                // Compile the type argument (first argument)
                self.compile_expr(&args[0])?;
                // Compile the value to convert
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Convert, 2));
                // Workaround: return Any (type depends on first arg at runtime) (Issue #2425)
                return Ok(ValueType::Any);
            }
            "promote" => {
                // promote(x, y, ...) - promote values to common type
                if args.is_empty() {
                    return err("promote requires at least 1 argument");
                }
                // Compile all arguments
                for arg in args {
                    self.compile_expr(arg)?;
                }
                self.emit(Instr::CallBuiltin(BuiltinId::Promote, args.len()));
                // Returns a tuple of promoted values
                return Ok(ValueType::Tuple);
            }
            "signed" => {
                // signed(x) - convert to signed integer
                if args.len() != 1 {
                    return err("signed requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Signed, 1));
                return Ok(ValueType::I64);
            }
            "unsigned" => {
                // unsigned(x) - convert to unsigned integer
                if args.len() != 1 {
                    return err("unsigned requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Unsigned, 1));
                return Ok(ValueType::I64);
            }
            // Note: float is now Pure Julia (number.jl + rational.jl + complex.jl, Issue #2722)
            "widemul" => {
                // widemul(a, b) - wide multiplication (no overflow)
                if args.len() != 2 {
                    return err("widemul requires exactly 2 arguments");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Widemul, 2));
                // Returns I64 if fits, otherwise F64
                return Ok(ValueType::Any);
            }
            "reinterpret" => {
                // reinterpret(T, x) - bit-level type reinterpretation
                if args.len() != 2 {
                    return err("reinterpret requires exactly 2 arguments");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Reinterpret, 2));
                // Return type depends on first argument
                return Ok(ValueType::Any);
            }
            "deepcopy" => {
                // deepcopy(x) - recursive deep copy
                if args.len() != 1 {
                    return err("deepcopy requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Deepcopy, 1));
                return Ok(ValueType::Any);
            }
            "_fieldnames" => {
                // _fieldnames(T) - internal builtin for tuple of field names
                if args.len() != 1 {
                    return err("_fieldnames requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Fieldnames, 1));
                return Ok(ValueType::Tuple);
            }
            "_fieldtypes" => {
                // _fieldtypes(T) - internal builtin for tuple of field types
                if args.len() != 1 {
                    return err("_fieldtypes requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Fieldtypes, 1));
                return Ok(ValueType::Tuple);
            }
            "_getfield" => {
                // _getfield(x, i) - internal builtin for runtime field access by index
                // This is used by dump() to access struct fields at runtime
                if args.len() != 2 {
                    return err("_getfield requires exactly 2 arguments: _getfield(x, i)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Getfield, 2));
                return Ok(ValueType::Any);
            }
            "_isabstracttype" => {
                // _isabstracttype(T) - internal intrinsic for type classification
                if args.len() != 1 {
                    return err("_isabstracttype requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Isabstracttype, 1));
                return Ok(ValueType::Bool);
            }
            "_isconcretetype" => {
                // _isconcretetype(T) - internal intrinsic for type classification
                if args.len() != 1 {
                    return err("_isconcretetype requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Isconcretetype, 1));
                return Ok(ValueType::Bool);
            }
            "_ismutabletype" => {
                // _ismutabletype(T) - internal intrinsic for type classification
                if args.len() != 1 {
                    return err("_ismutabletype requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Ismutabletype, 1));
                return Ok(ValueType::Bool);
            }
            // Hash intrinsic (Issue #2582)
            "_hash" => {
                // _hash(x) - internal intrinsic for hash computation
                if args.len() != 1 {
                    return err("_hash requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Hash, 1));
                return Ok(ValueType::I64);
            }
            // Eltype intrinsic (Issue #2570)
            "_eltype" => {
                // _eltype(x) - internal intrinsic for element type
                if args.len() != 1 {
                    return err("_eltype requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_Eltype, 1));
                return Ok(ValueType::DataType);
            }
            // Dict internal intrinsics (Issue #2572)
            "_dict_get" => {
                if args.len() != 2 {
                    return err("_dict_get requires exactly 2 arguments: _dict_get(d, key)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictGet, 2));
                return Ok(ValueType::Any);
            }
            "_dict_set!" => {
                if args.len() != 3 {
                    return err(
                        "_dict_set! requires exactly 3 arguments: _dict_set!(d, key, value)",
                    );
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.compile_expr(&args[2])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictSet, 3));
                return Ok(ValueType::Dict);
            }
            "_dict_delete!" => {
                if args.len() != 2 {
                    return err(
                        "_dict_delete! requires exactly 2 arguments: _dict_delete!(d, key)",
                    );
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictDelete, 2));
                return Ok(ValueType::Any);
            }
            "_dict_haskey" => {
                if args.len() != 2 {
                    return err("_dict_haskey requires exactly 2 arguments: _dict_haskey(d, key)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictHaskey, 2));
                return Ok(ValueType::Bool);
            }
            "_dict_length" => {
                if args.len() != 1 {
                    return err("_dict_length requires exactly 1 argument: _dict_length(d)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictLength, 1));
                return Ok(ValueType::I64);
            }
            "_dict_empty!" => {
                if args.len() != 1 {
                    return err("_dict_empty! requires exactly 1 argument: _dict_empty!(d)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictEmpty, 1));
                return Ok(ValueType::Dict);
            }
            // Dict collection intrinsics (Issue #2669)
            "_dict_keys" => {
                if args.len() != 1 {
                    return err("_dict_keys requires exactly 1 argument: _dict_keys(d)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictKeys, 1));
                return Ok(ValueType::Tuple);
            }
            "_dict_values" => {
                if args.len() != 1 {
                    return err("_dict_values requires exactly 1 argument: _dict_values(d)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictValues, 1));
                return Ok(ValueType::Tuple);
            }
            "_dict_pairs" => {
                if args.len() != 1 {
                    return err("_dict_pairs requires exactly 1 argument: _dict_pairs(d)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_DictPairs, 1));
                return Ok(ValueType::Tuple);
            }
            // Set internal intrinsics (Issue #2574)
            "_set_push!" => {
                if args.len() != 2 {
                    return err("_set_push! requires exactly 2 arguments: _set_push!(s, x)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_SetPush, 2));
                return Ok(ValueType::Set);
            }
            "_set_delete!" => {
                if args.len() != 2 {
                    return err("_set_delete! requires exactly 2 arguments: _set_delete!(s, x)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_SetDelete, 2));
                return Ok(ValueType::Set);
            }
            "_set_in" => {
                if args.len() != 2 {
                    return err("_set_in requires exactly 2 arguments: _set_in(x, s)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_SetIn, 2));
                return Ok(ValueType::Bool);
            }
            "_set_empty!" => {
                if args.len() != 1 {
                    return err("_set_empty! requires exactly 1 argument: _set_empty!(s)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_SetEmpty, 1));
                return Ok(ValueType::Set);
            }
            "_set_length" => {
                if args.len() != 1 {
                    return err("_set_length requires exactly 1 argument: _set_length(s)");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::_SetLength, 1));
                return Ok(ValueType::I64);
            }
            "getfield" => {
                // getfield(x, name) or getfield(x, i) - get field by name (Symbol) or index (Int)
                // This is the public Julia API for field access
                if args.len() != 2 {
                    return err("getfield requires exactly 2 arguments: getfield(x, name) or getfield(x, i)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Getfield, 2));
                return Ok(ValueType::Any);
            }
            "setfield!" => {
                // setfield!(x, name, v) or setfield!(x, i, v) - set field by name (Symbol) or index (Int)
                // This is the public Julia API for field mutation
                if args.len() != 3 {
                    return err("setfield! requires exactly 3 arguments: setfield!(x, name, v) or setfield!(x, i, v)");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.compile_expr(&args[2])?;
                self.emit(Instr::CallBuiltin(BuiltinId::Setfield, 3));
                return Ok(ValueType::Any);
            }
            // Test builtins - for Pure Julia @test/@testset/@test_throws macros
            "_test_record!" => {
                if args.len() != 2 {
                    return err("_test_record! requires exactly 2 arguments");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::TestRecord, 2));
                return Ok(ValueType::Nothing);
            }
            "_test_record_broken!" => {
                if args.len() != 2 {
                    return err("_test_record_broken! requires exactly 2 arguments");
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.emit(Instr::CallBuiltin(BuiltinId::TestRecordBroken, 2));
                return Ok(ValueType::Nothing);
            }
            "_testset_begin!" => {
                if args.len() != 1 {
                    return err("_testset_begin! requires exactly 1 argument");
                }
                self.compile_expr(&args[0])?;
                self.emit(Instr::CallBuiltin(BuiltinId::TestSetBegin, 1));
                return Ok(ValueType::Nothing);
            }
            "_testset_end!" => {
                if !args.is_empty() {
                    return err("_testset_end! takes no arguments");
                }
                self.emit(Instr::CallBuiltin(BuiltinId::TestSetEnd, 0));
                return Ok(ValueType::Nothing);
            }
            // Regex replace builtin (Issue #2112)
            "_regex_replace" => {
                if args.len() != 4 {
                    return err(
                        "_regex_replace requires 4 arguments: _regex_replace(string, regex, replacement, count)",
                    );
                }
                self.compile_expr(&args[0])?;
                self.compile_expr(&args[1])?;
                self.compile_expr(&args[2])?;
                self.compile_expr(&args[3])?;
                self.emit(Instr::CallBuiltin(BuiltinId::RegexReplace, 4));
                return Ok(ValueType::Str);
            }
            _ => {}
        }

        // Handle Dict() without type parameters
        // Only intercept known built-in patterns (empty or pair args);
        // fall through for struct constructor patterns (Issue #2748)
        if function == "Dict" {
            let is_builtin_pattern = args.is_empty()
                || args.iter().all(|a| matches!(a, Expr::Pair { .. }))
                || args.len() == 1
                    && matches!(
                        &args[0],
                        Expr::Comprehension { .. } | Expr::Generator { .. }
                    );
            if is_builtin_pattern {
                return self.compile_dict_constructor(args);
            }
            // Fall through to generic call path for non-pair args (e.g., Dict struct constructor)
        }

        // Handle Set() without type parameters
        if function == "Set" {
            return self.compile_set_constructor(args);
        }

        // Handle Array() and Vector() without type parameters
        if function == "Array" || function == "Vector" {
            return self.compile_array_constructor(&[], args);
        }

        // Check for explicit parametric type constructor: Point{Float64}(...) or Dict{String, Int}()
        if let Some((base_name, type_args)) = parse_parametric_call(function) {
            // Handle Dict{K, V}() - built-in parametric type
            // Only intercept known built-in patterns; fall through for struct constructor (Issue #2748)
            if base_name == "Dict" {
                let is_builtin_pattern = args.is_empty()
                    || args.iter().all(|a| matches!(a, Expr::Pair { .. }))
                    || args.len() == 1
                        && matches!(
                            &args[0],
                            Expr::Comprehension { .. } | Expr::Generator { .. }
                        );
                if is_builtin_pattern {
                    return self.compile_dict_constructor_typed(&type_args, args);
                }
                // Fall through to struct constructor for non-builtin patterns
            }
            // Handle Set{T}() - built-in parametric type
            if base_name == "Set" {
                return self.compile_set_constructor(args);
            }
            // Handle Array{T}() and Vector{T}() - built-in parametric types
            // Only intercept known built-in patterns; fall through for struct constructor patterns
            // (e.g., Array{T,N}(mem, size) for Pure Julia Array struct) (Issue #2760)
            if base_name == "Array" || base_name == "Vector" {
                let is_builtin_pattern = args.is_empty()
                    || args.len() == 1
                    || matches!(&args[0], Expr::Var(name, _) if name == "undef");
                if is_builtin_pattern {
                    return self.compile_array_constructor(&type_args, args);
                }
                // Fall through to struct constructor for non-builtin patterns
            }
            // Handle Memory{T}(n) - built-in parametric type
            if base_name == "Memory" {
                return self.compile_memory_constructor(&type_args, args);
            }
            // Check if any type_arg is a type variable (like Rational{T} in a where T function)
            // or a local DataType variable (like Point{Tnew} where Tnew = promote_type(...))
            // or a runtime expression (like Symbol(s) in MIME{Symbol(s)})
            // If so, we can't instantiate at compile time - need runtime construction
            let has_type_var = type_args.iter().any(|arg| {
                match arg {
                    TypeExpr::TypeVar(name) => {
                        // Pure numeric strings (like "5" in Val{5}) are VALUE parameters, not type variables
                        // They should be preserved as-is in the type name
                        if name.chars().all(|c| c.is_ascii_digit()) {
                            return false; // Not a type variable, just a value parameter
                        }
                        // Type variable from where clause (short uppercase like T, T1)
                        let is_where_type_var = name.len() <= 2
                            && name
                                .chars()
                                .all(|c| c.is_ascii_uppercase() || c.is_ascii_digit());
                        // Local variable holding a DataType value
                        let is_local_datatype = self.locals.get(name) == Some(&ValueType::DataType);
                        is_where_type_var || is_local_datatype
                    }
                    TypeExpr::RuntimeExpr(_) => true, // Runtime expressions need dynamic construction
                    _ => false,
                }
            });
            // Check if we need dynamic struct construction (type arg is a local DataType variable
            // or a type parameter from where clause or a runtime expression)
            let needs_dynamic_construction = type_args.iter().any(|arg| {
                match arg {
                    TypeExpr::TypeVar(name) => {
                        // Local DataType variable
                        let is_local_datatype = self.locals.get(name) == Some(&ValueType::DataType);
                        // Type parameter from where clause (current_type_params)
                        let is_type_param =
                            self.current_type_param_index.contains_key(name.as_str());
                        is_local_datatype || is_type_param
                    }
                    TypeExpr::RuntimeExpr(_) => true, // Runtime expressions always need dynamic construction
                    _ => false,
                }
            });
            if needs_dynamic_construction {
                // Use dynamic parametric struct construction
                return self.compile_dynamic_parametric_struct(&base_name, &type_args, args);
            }
            if !has_type_var {
                // Explicit type parameters provided for user-defined structs (including Complex)
                // Check if there's an inner constructor for this struct in method_tables
                // Inner constructors are identified by having type_params (where clause)
                // This distinguishes them from outer constructors like Rational(num::Int64, den::Int64)
                if let Some(table) = self.method_tables.get(&base_name) {
                    // Find inner constructors only (those with type_params, not outer constructors)
                    let arg_types: Vec<JuliaType> =
                        args.iter().map(|a| self.infer_julia_type(a)).collect();
                    // Try to find a matching method that has type parameters (inner constructor)
                    let inner_ctor_match = table
                        .methods
                        .iter()
                        .filter(|m| !m.type_params.is_empty()) // Inner constructors have where clause
                        .find(|m| m.params.len() == arg_types.len());
                    if let Some(method) = inner_ctor_match {
                        // Compile arguments
                        for arg in args {
                            self.compile_expr(arg)?;
                        }
                        // Call the inner constructor
                        self.emit(Instr::Call(method.global_index, args.len()));
                        // For parametric structs with explicit type params like Rational{Int64}(...),
                        // resolve the concrete type_id and return Struct type instead of Any
                        // This ensures the variable gets the correct struct type for method dispatch
                        let resolved_type_id = self
                            .shared_ctx
                            .resolve_instantiation_with_type_expr(&base_name, &type_args)?;
                        return Ok(ValueType::Struct(resolved_type_id));
                    }
                    // If no inner constructor found, fall through to default constructor
                }
                // No inner constructors or dispatch failed - use default struct constructor
                let type_id = self
                    .shared_ctx
                    .resolve_instantiation_with_type_expr(&base_name, &type_args)?;
                let struct_info = self
                    .shared_ctx
                    .struct_table
                    .values()
                    .find(|s| s.type_id == type_id)
                    .cloned()
                    .ok_or_else(|| {
                        CompileError::Msg("Internal error: instantiation not found".to_string())
                    })?;
                return self.compile_struct_constructor(struct_info, args);
            }
            // Type variable detected (e.g., Rational{T}(...) in a where T function)
            // When type variables are present, we cannot know the exact type at compile time.
            // Instead of inferring from arguments (which may fail for type bounds),
            // instantiate with Any to defer type resolution to runtime.
            // Resolve to qualified name for module structs (e.g., Point -> MyGeometry.Point)
            if let Some(resolved_name) = self.resolve_parametric_struct_name(&base_name) {
                // Check if the struct has inner constructors (methods in method_tables)
                // If so, use method dispatch to call the inner constructor instead of
                // bypassing it with compile_struct_constructor
                if let Some(table) = self.method_tables.get(&base_name) {
                    // Inner constructors exist - dispatch to them
                    // Infer argument types for dispatch
                    let arg_types: Vec<JuliaType> =
                        args.iter().map(|a| self.infer_julia_type(a)).collect();

                    // Find the best matching method
                    if let Ok(method) = table.dispatch(&arg_types) {
                        // Compile arguments
                        for arg in args {
                            self.compile_expr(arg)?;
                        }
                        // Call the inner constructor
                        self.emit(Instr::Call(method.global_index, args.len()));
                        // For type variable constructors like Rational{T}(...), return Struct type
                        // with the generic instantiation (Rational{Any}) so method dispatch works
                        let type_id = self
                            .shared_ctx
                            .resolve_instantiation(&resolved_name, &[JuliaType::Any])?;
                        return Ok(ValueType::Struct(type_id));
                    }
                    // If dispatch fails, fall through to default constructor
                }
                // No inner constructors or dispatch failed - use default struct constructor
                // Use Any as the type parameter - this will pass all bound checks
                // and the runtime will handle the actual type
                let type_id = self
                    .shared_ctx
                    .resolve_instantiation(&resolved_name, &[JuliaType::Any])?;
                let struct_info = self
                    .shared_ctx
                    .struct_table
                    .values()
                    .find(|s| s.type_id == type_id)
                    .cloned()
                    .ok_or_else(|| {
                        CompileError::Msg("Internal error: instantiation not found".to_string())
                    })?;
                return self.compile_struct_constructor(struct_info, args);
            }
        }

        // Check if this is a concrete struct constructor
        // If method_tables has an entry for this struct name, use dispatch (inner constructors)
        // Otherwise, use the default constructor
        if let Some(struct_info) = self.shared_ctx.struct_table.get(function) {
            if !self.method_tables.contains_key(function) {
                return self.compile_struct_constructor(struct_info.clone(), args);
            }
            // Check if argument types exactly match struct field types
            // In this case, use the default constructor to avoid infinite recursion
            // when outer constructors like `Year(v::Int) = Year(Int64(v))` exist
            // BUT: don't apply this shortcut if the struct has inner constructors,
            // because inner constructors should always be dispatched (they use `new()` internally)
            if !struct_info.has_inner_constructor && args.len() == struct_info.fields.len() {
                let arg_types: Vec<JuliaType> =
                    args.iter().map(|a| self.infer_julia_type(a)).collect();
                let field_types: Vec<JuliaType> = struct_info
                    .fields
                    .iter()
                    .map(|(_, vt)| self.value_type_to_julia_type(vt))
                    .collect();
                // Check if types match, with Any matching any type
                // This prevents infinite recursion when outer constructors exist
                // and the argument type is not statically known
                let all_match = arg_types
                    .iter()
                    .zip(field_types.iter())
                    .all(|(arg, field)| {
                        arg == field ||
                        // Field is Any - accepts any argument type (for untyped struct fields like CartesianIndices.dims)
                        matches!(field, JuliaType::Any) ||
                        // Allow Any arg to match builtin numeric fields (common case for function return values)
                        (matches!(arg, JuliaType::Any) && field.is_builtin_numeric())
                    });
                if all_match {
                    return self.compile_struct_constructor(struct_info.clone(), args);
                }
            }
            // Fall through to method dispatch for inner constructors
        }

        // Check if this is a parametric struct constructor with type inference
        if let Some(resolved_name) = self.resolve_parametric_struct_name(function) {
            // If there are methods defined for this name (like Complex(x::Int64)), try method dispatch first
            // This allows user-defined constructors to take precedence over the default struct constructor
            if !self.method_tables.contains_key(function) {
                // No custom constructors - use default struct constructor
                // Use resolved (qualified) name for instantiation so method dispatch works correctly
                let arg_types: Vec<JuliaType> =
                    args.iter().map(|a| self.infer_julia_type(a)).collect();
                let type_args = self.shared_ctx.infer_type_args(function, &arg_types)?;
                let type_id = self
                    .shared_ctx
                    .resolve_instantiation(&resolved_name, &type_args)?;
                let struct_info = self
                    .shared_ctx
                    .struct_table
                    .values()
                    .find(|s| s.type_id == type_id)
                    .cloned()
                    .ok_or_else(|| {
                        CompileError::Msg("Internal error: instantiation not found".to_string())
                    })?;
                return self.compile_struct_constructor(struct_info, args);
            }
            // Fall through to method dispatch for custom constructors
        }

        // Special case: sprint(f, args...) with function reference as first argument
        // When the first argument is a FunctionRef (lambda or named function reference),
        // use the builtin_hof handler which can actually call the function.
        // This takes precedence over the Pure Julia sprint(x) implementation which
        // would just convert the function to its string representation.
        // See Issue #402: sprint(f, args...) only works with user-defined functions
        if function == "sprint" && !args.is_empty() {
            let is_func_ref = match &args[0] {
                Expr::FunctionRef { .. } => true,
                Expr::Var(name, _) => self.method_tables.contains_key(name),
                _ => false,
            };
            if is_func_ref {
                // Check for context kwarg (Issue #334: IOContext support for sprint)
                let context_kwarg = kwargs.iter().find(|(k, _)| k == "context");
                if let Some((_, context_expr)) = context_kwarg {
                    // When context is provided, call sprint_context(f, args, context)
                    // This routes to the Pure Julia implementation that respects IOContext properties
                    let mut sprint_context_args = vec![args[0].clone()];

                    // Create a tuple for the remaining args
                    let remaining_args = if args.len() > 1 {
                        Expr::TupleLiteral {
                            elements: args[1..].to_vec(),
                            span: args[0].span(),
                        }
                    } else {
                        Expr::TupleLiteral {
                            elements: vec![],
                            span: args[0].span(),
                        }
                    };
                    sprint_context_args.push(remaining_args);
                    sprint_context_args.push(context_expr.clone());

                    return self.compile_call(
                        "sprint_context",
                        &sprint_context_args,
                        &[],
                        &[],
                        &[],
                    );
                } else {
                    // No context kwarg - use the fast builtin SprintFunc instruction
                    return self.compile_builtin_call(function, args);
                }
            }
        }

        // Special case: floor(x; digits=N) or floor(x; sigdigits=N) (Issue #2054)
        if function == "floor" && args.len() == 1 && !kwargs.is_empty() {
            if let Some(digits_expr) = kwargs.iter().find(|(k, _)| k == "digits").map(|(_, v)| v) {
                self.compile_expr(&args[0])?;
                self.compile_expr(digits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::FloorDigits, 2));
                return Ok(ValueType::F64);
            }
            if let Some(sigdigits_expr) = kwargs
                .iter()
                .find(|(k, _)| k == "sigdigits")
                .map(|(_, v)| v)
            {
                self.compile_expr(&args[0])?;
                self.compile_expr(sigdigits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::FloorSigDigits, 2));
                return Ok(ValueType::F64);
            }
        }

        // Special case: ceil(x; digits=N) or ceil(x; sigdigits=N) (Issue #2054)
        if function == "ceil" && args.len() == 1 && !kwargs.is_empty() {
            if let Some(digits_expr) = kwargs.iter().find(|(k, _)| k == "digits").map(|(_, v)| v) {
                self.compile_expr(&args[0])?;
                self.compile_expr(digits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::CeilDigits, 2));
                return Ok(ValueType::F64);
            }
            if let Some(sigdigits_expr) = kwargs
                .iter()
                .find(|(k, _)| k == "sigdigits")
                .map(|(_, v)| v)
            {
                self.compile_expr(&args[0])?;
                self.compile_expr(sigdigits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::CeilSigDigits, 2));
                return Ok(ValueType::F64);
            }
        }

        // Special case: round(x; digits=N) or round(x; sigdigits=N) (Issue #2051)
        if function == "round" && args.len() == 1 && !kwargs.is_empty() {
            if let Some(digits_expr) = kwargs.iter().find(|(k, _)| k == "digits").map(|(_, v)| v) {
                self.compile_expr(&args[0])?;
                self.compile_expr(digits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::RoundDigits, 2));
                return Ok(ValueType::F64);
            }
            if let Some(sigdigits_expr) = kwargs
                .iter()
                .find(|(k, _)| k == "sigdigits")
                .map(|(_, v)| v)
            {
                self.compile_expr(&args[0])?;
                self.compile_expr(sigdigits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::RoundSigDigits, 2));
                return Ok(ValueType::F64);
            }
        }

        // Special case: trunc(x; digits=N) or trunc(x; sigdigits=N) (Issue #2059)
        if function == "trunc" && args.len() == 1 && !kwargs.is_empty() {
            if let Some(digits_expr) = kwargs.iter().find(|(k, _)| k == "digits").map(|(_, v)| v) {
                self.compile_expr(&args[0])?;
                self.compile_expr(digits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::TruncDigits, 2));
                return Ok(ValueType::F64);
            }
            if let Some(sigdigits_expr) = kwargs
                .iter()
                .find(|(k, _)| k == "sigdigits")
                .map(|(_, v)| v)
            {
                self.compile_expr(&args[0])?;
                self.compile_expr(sigdigits_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::TruncSigDigits, 2));
                return Ok(ValueType::F64);
            }
        }

        // Special case: string(x; base=N) - integer to string with base (Issue #2036)
        if function == "string" && args.len() == 1 && !kwargs.is_empty() {
            if let Some(base_expr) = kwargs.iter().find(|(k, _)| k == "base").map(|(_, v)| v) {
                self.compile_expr(&args[0])?;
                self.compile_expr(base_expr)?;
                self.emit(Instr::CallBuiltin(BuiltinId::StringIntToBase, 2));
                return Ok(ValueType::Str);
            }
        }

        // Special case: mapreduce/mapfoldl/mapfoldr with init keyword argument (Issue #2077)
        // mapreduce(f, op, arr; init=val) => mapreduce(f, op, arr, val)
        if matches!(function, "mapreduce" | "mapfoldl" | "mapfoldr")
            && args.len() == 3
            && !kwargs.is_empty()
        {
            if let Some(init_expr) = kwargs.iter().find(|(k, _)| k == "init").map(|(_, v)| v) {
                let mut extended_args = args.to_vec();
                extended_args.push(init_expr.clone());
                return self.compile_builtin_call(function, &extended_args);
            }
        }

        // Special case: reduce/foldl/foldr with init keyword argument (Issue #2077, #2084)
        // reduce(op, itr; init=val) => reduce(op, itr, val)
        // Keyword-only Pure Julia wrapper methods shadow positional 3-arg methods,
        // so we handle keyword→positional conversion at compiler level instead.
        if matches!(function, "reduce" | "foldl" | "foldr") && args.len() == 2 && !kwargs.is_empty()
        {
            if let Some(init_expr) = kwargs.iter().find(|(k, _)| k == "init").map(|(_, v)| v) {
                let mut extended_args = args.to_vec();
                extended_args.push(init_expr.clone());
                return self.compile_call(function, &extended_args, &[], &[], &[]);
            }
        }

        // Special case: parse(T, s) and tryparse(T, s) - type parsing
        // Float64 parse/tryparse remain as Rust builtins (uses libc strtod)
        // Int64/Int parse/tryparse are now Pure Julia (base/parse.jl)
        if (function == "parse" || function == "tryparse") && args.len() == 2 {
            let is_float_type = match &args[0] {
                Expr::Var(name, _) => {
                    matches!(name.as_str(), "Float64" | "Float")
                }
                _ => false,
            };
            if is_float_type {
                return self.compile_builtin_call(function, args);
            }
            // Int64/Int: fall through to method dispatch (Pure Julia in base/parse.jl)
            // But handle parse(Int, s; base=N) kwargs by routing to builtin
            if function == "parse" {
                let is_int_type = match &args[0] {
                    Expr::Var(name, _) => {
                        matches!(name.as_str(), "Int64" | "Int")
                    }
                    _ => false,
                };
                if is_int_type {
                    if let Some(base_expr) =
                        kwargs.iter().find(|(k, _)| k == "base").map(|(_, v)| v)
                    {
                        self.compile_expr(&args[1])?;
                        self.compile_expr(base_expr)?;
                        self.emit(Instr::CallBuiltin(BuiltinId::StringToIntBase, 2));
                        return Ok(ValueType::I64);
                    }
                }
            }
        }

        // Check if this is a user-defined function with potential multiple dispatch
        if let Some(table) = self.method_tables.get(function) {
            // Check if the function is accessible (top-level or imported via using)
            if !self.imported_functions.contains(function) {
                return err(format!(
                    "function '{}' is not imported. Use 'using ModuleName' or 'using ModuleName: {}' to import it, or use 'ModuleName.{}()' for qualified access.",
                    function, function, function
                ));
            }

            // Infer argument types for dispatch
            let arg_types: Vec<JuliaType> = args.iter().map(|a| self.infer_julia_type(a)).collect();

            // Check if any argument type is Any - this requires runtime dispatch
            let has_any_arg = arg_types.iter().any(|t| matches!(t, JuliaType::Any));
            let has_multiple_methods = table.methods.len() > 1;

            // Find the best matching method
            // If dispatch fails for a known base function, fall back to the builtin implementation
            let method = match table.dispatch(&arg_types) {
                Ok(m) => m,
                Err(_) if is_base_function(function) && !has_any_arg => {
                    // Fallback to builtin for known base functions (e.g., floor(Float64))
                    // BUT only when argument types are known at compile time.
                    // When has_any_arg is true, we fall through to runtime dispatch instead,
                    // which allows user-defined methods (like Float64(::MyType)) to be called.
                    // Try BuiltinOp first (handles iterate, typeof, etc. with proper types)
                    if let Some(builtin_op) = base_function_to_builtin_op(function) {
                        return self.compile_builtin(&builtin_op, args);
                    }
                    return self.compile_builtin_call(function, args);
                }
                Err(crate::types::DispatchError::NoMethodFound { .. })
                    if is_builtin_type_name(function) && args.len() == 1 && !has_any_arg =>
                {
                    // Fallback to builtin type constructor when user-defined method doesn't match
                    // AND the argument type is known at compile time (not Any).
                    // This handles cases like Float64(42) when user defined Float64(::MyType)
                    // but there's no Float64(::Int64) method.
                    // When has_any_arg is true, we fall through to runtime dispatch instead.
                    return self.compile_builtin_call(function, args);
                }
                Err(crate::types::DispatchError::NoMethodFound { .. })
                    if is_reducible_nary_operator(function) && args.len() > 2 =>
                {
                    // Julia semantics: when no specific n-arg method exists for operators like +/*,
                    // n-arg calls like +(a, b, c) reduce to +(+(a, b), c).
                    // This is Julia's generic: +(a, b, c, xs...) = afoldl(+, a+b, c, xs...)
                    // This works regardless of whether the methods are Base extensions or user-defined,
                    // as long as there's no specific n-arg method that matches the argument types.
                    return self.compile_nary_operator_reduction(function, args);
                }
                Err(crate::types::DispatchError::NoMethodFound { .. })
                    if has_any_arg && args.len() == 1 =>
                {
                    // For functions that have builtin fallbacks (floor, ceil, etc.), use the builtin path
                    // which has CallDynamicOrBuiltin support for runtime dispatch with builtin fallback.
                    // This includes:
                    // - Rounding functions (floor, ceil, round, trunc) with Rational methods
                    // - Math functions (sqrt, abs, sign) with struct methods
                    // - I/O functions (take!) that have both builtin (IOBuffer) and Julia (Channel) methods
                    // All should fall back to builtin for Float64/Int64 or IO types.
                    // Note: sin, cos, tan, exp, log removed — now Pure Julia (base/math.jl)
                    match function {
                        // Note: sin, cos, tan, exp, log removed — now Pure Julia (base/math.jl)
                        "floor" | "ceil" | "round" | "trunc" | "sqrt" | "abs" | "sign"
                        | "take!" | "takestring!" => {
                            return self.compile_builtin_call(function, args);
                        }
                        _ => {}
                    }

                    // When argument type is Any (compile-time unknown) and there are methods,
                    // use runtime dispatch. This handles cases like inv(x) where x::Rational{T}.
                    // At compile time we don't know the concrete type, so we dispatch at runtime.
                    for arg in args {
                        self.compile_expr(arg)?;
                    }

                    // Build candidates for runtime dispatch from all single-arg methods
                    let candidates: Vec<(usize, String)> = table
                        .methods
                        .iter()
                        .filter(|m| m.params.len() == 1)
                        .map(|m| {
                            let type_name = m.params[0].1.to_string();
                            (m.global_index, type_name)
                        })
                        .collect();

                    if !candidates.is_empty() {
                        // Use the first method as fallback
                        let fallback_index = candidates[0].0;
                        self.emit(Instr::CallDynamic(fallback_index, 1, candidates));
                        // Return Any since we don't know the concrete return type
                        // (iterate() returns Tuple or Nothing - IndexLoad handles both at runtime)
                        return Ok(ValueType::Any);
                    }

                    // No method candidates - check if this is a struct constructor
                    // If so, fall back to the default struct constructor
                    if let Some(struct_info) = self.shared_ctx.struct_table.get(function) {
                        if struct_info.fields.len() == args.len() {
                            return self.compile_struct_constructor(struct_info.clone(), args);
                        }
                    }

                    // No candidates found - fall through to error
                    return err(format!("No method matching {}({:?})", function, arg_types));
                }
                Err(crate::types::DispatchError::NoMethodFound { .. })
                    if has_any_arg && args.len() >= 2 =>
                {
                    // When argument types include Any (compile-time unknown) for multi-arg functions,
                    // use runtime dispatch. This handles cases like gcd(a, b) where a, b have type T.
                    for arg in args {
                        self.compile_expr(arg)?;
                    }

                    // Build candidates for runtime dispatch from all matching-arity methods
                    let candidates: Vec<(usize, Vec<String>)> = table
                        .methods
                        .iter()
                        .filter(|m| m.params.len() == args.len())
                        .map(|m| {
                            let type_names: Vec<String> =
                                m.params.iter().map(|(_, ty)| ty.to_string()).collect();
                            (m.global_index, type_names)
                        })
                        .collect();

                    if !candidates.is_empty() {
                        if candidates.len() == 1 {
                            self.emit_call_or_specialize(function, candidates[0].0, args.len());
                        } else {
                            // Use the first method as fallback
                            let fallback_index = candidates[0].0;
                            self.emit(Instr::CallTypedDispatch(
                                function.to_string(),
                                args.len(),
                                fallback_index,
                                candidates,
                            ));
                        }
                        // Return Any since we don't know the concrete return type
                        // (iterate() returns Tuple or Nothing - IndexLoad handles both at runtime)
                        return Ok(ValueType::Any);
                    }

                    // No candidates found - fall through to error
                    return err(format!("No method matching {}({:?})", function, arg_types));
                }
                Err(crate::types::DispatchError::AmbiguousMethod { .. }) => {
                    // Check if this is a Type{T} dispatch scenario:
                    // - All argument types are DataType (type values)
                    // - Methods have TypeOf patterns in their parameters
                    let all_datatype_args =
                        arg_types.iter().all(|t| matches!(t, JuliaType::DataType));
                    let has_typeof_methods = table.methods.iter().any(|m| {
                        m.params
                            .iter()
                            .any(|(_, ty)| matches!(ty, JuliaType::TypeOf(_)))
                    });

                    if all_datatype_args && has_typeof_methods {
                        // Compile arguments - they are type values (DataType)
                        for arg in args {
                            self.compile_expr(arg)?;
                        }

                        // Build candidates for runtime typed dispatch
                        // Each candidate is (func_index, expected_type_names)
                        let candidates: Vec<(usize, Vec<String>)> = table
                            .methods
                            .iter()
                            .filter(|m| m.params.len() == args.len())
                            .map(|m| {
                                let type_names: Vec<String> = m
                                    .params
                                    .iter()
                                    .map(|(_, ty)| match ty {
                                        JuliaType::TypeOf(inner) => inner.name().to_string(),
                                        _ => ty.name().to_string(),
                                    })
                                    .collect();
                                (m.global_index, type_names)
                            })
                            .collect();

                        // Find the fallback method (one with TypeVar patterns - generic version)
                        let fallback_index = table.methods.iter()
                            .find(|m| m.params.iter().any(|(_, ty)| {
                                matches!(ty, JuliaType::TypeOf(inner) if matches!(inner.as_ref(), JuliaType::TypeVar(_, _)))
                            }))
                            .map(|m| m.global_index)
                            .unwrap_or(candidates.first().map(|(idx, _)| *idx).unwrap_or(0));

                        if candidates.len() == 1 && candidates[0].0 == fallback_index {
                            self.emit_call_or_specialize(function, candidates[0].0, args.len());
                        } else {
                            self.emit(Instr::CallTypedDispatch(
                                function.to_string(),
                                args.len(),
                                fallback_index,
                                candidates,
                            ));
                        }

                        // Return type is typically Any, but override for type-returning functions
                        let return_type = match function {
                            "promote_type" | "promote_rule" | "typeof" | "eltype" | "keytype"
                            | "valtype" => ValueType::DataType,
                            _ => ValueType::Any,
                        };
                        return Ok(return_type);
                    }

                    // Check if any argument is Any - use runtime dispatch in that case
                    if has_any_arg {
                        // Compile arguments
                        for arg in args {
                            self.compile_expr(arg)?;
                        }

                        // Build candidates for runtime dispatch
                        // Each candidate is (func_index, expected_type_names)
                        let candidates: Vec<(usize, Vec<String>)> = table
                            .methods
                            .iter()
                            .filter(|m| m.params.len() == args.len())
                            .map(|m| {
                                let type_names: Vec<String> = m
                                    .params
                                    .iter()
                                    .map(|(_, ty)| match ty {
                                        JuliaType::TypeOf(inner) => inner.name().to_string(),
                                        _ => ty.name().to_string(),
                                    })
                                    .collect();
                                (m.global_index, type_names)
                            })
                            .collect();

                        if !candidates.is_empty() {
                            if candidates.len() == 1 {
                                self.emit_call_or_specialize(function, candidates[0].0, args.len());
                            } else {
                                // Use the first candidate as fallback
                                let fallback_index = candidates[0].0;
                                self.emit(Instr::CallTypedDispatch(
                                    function.to_string(),
                                    args.len(),
                                    fallback_index,
                                    candidates,
                                ));
                            }
                            // Return Any since we don't know the concrete return type
                            // (iterate() returns Tuple or Nothing - IndexLoad handles both at runtime)
                            return Ok(ValueType::Any);
                        }
                    }

                    // Not a Type{T} dispatch scenario and no Any args - return the original error
                    return Err(CompileError::Dispatch(
                        crate::types::DispatchError::AmbiguousMethod {
                            name: function.to_string(),
                            arg_types: arg_types.clone(),
                            candidates: table
                                .methods
                                .iter()
                                .filter(|m| m.params.len() == args.len())
                                .map(|m| m.params.iter().map(|(_, ty)| ty.clone()).collect())
                                .collect(),
                        },
                    ));
                }
                Err(e) => return Err(CompileError::Dispatch(e)),
            };

            // Compile positional arguments with expected types
            // IMPORTANT: When has_any_arg is true AND has_multiple_methods is true AND single-arg,
            // we'll use runtime dispatch (CallDynamic). In that case, we should NOT coerce arguments
            // based on the statically-selected method's param types, because the actual runtime type
            // might match a different method. Compile args without coercion to preserve their types.
            let use_runtime_dispatch =
                has_any_arg && has_multiple_methods && args.len() == 1 && kwargs.is_empty();

            // Handle varargs functions differently - compile all args
            if let Some(vararg_idx) = method.vararg_param_index {
                // Compile fixed params with their expected types
                for (idx, arg) in args.iter().enumerate() {
                    if idx < vararg_idx {
                        // Fixed parameter - use expected type ONLY if not using runtime dispatch
                        if use_runtime_dispatch {
                            // Runtime dispatch: don't coerce, preserve original type
                            self.compile_expr(arg)?;
                        } else if let Some((_, param_ty)) = method.params.get(idx) {
                            if *param_ty == JuliaType::Any
                                || param_ty.is_narrow_integer()
                                || param_ty.is_abstract_integer()
                            {
                                self.compile_expr(arg)?;
                            } else {
                                let vt = julia_type_to_value_type(param_ty);
                                self.compile_expr_as(arg, vt)?;
                            }
                        } else {
                            self.compile_expr(arg)?;
                        }
                    } else {
                        // Varargs - compile as-is
                        self.compile_expr(arg)?;
                    }
                }
            } else {
                // Non-varargs: compile args paired with params
                for (arg, (_, param_ty)) in args.iter().zip(method.params.iter()) {
                    // When using runtime dispatch, don't coerce - preserve original type
                    if use_runtime_dispatch {
                        self.compile_expr(arg)?;
                    } else if *param_ty == JuliaType::Any {
                        // For `Any` typed parameters, don't coerce - just compile the argument as-is
                        self.compile_expr(arg)?;
                    } else if param_ty.is_narrow_integer() || param_ty.is_abstract_integer() {
                        // For narrow integer types (Int8, Int16, Int32, UInt*, Bool, Int128)
                        // and abstract integer supertypes (Integer, Signed, Unsigned, Real, Number),
                        // don't coerce to I64 - preserve the specific type so the function
                        // body receives the correct Value variant (e.g., Value::I32 not Value::I64).
                        self.compile_expr(arg)?;
                    } else {
                        let vt = julia_type_to_value_type(param_ty);
                        self.compile_expr_as(arg, vt)?;
                    }
                }
            }

            if kwargs.is_empty() {
                // Check if runtime dispatch is needed
                if has_any_arg && has_multiple_methods && args.len() == 1 {
                    // Build candidates for runtime dispatch (single-arg)
                    // Each candidate is (func_index, expected_type_name)
                    let candidates: Vec<(usize, String)> = table
                        .methods
                        .iter()
                        .filter(|m| m.params.len() == 1 && !matches!(m.params[0].1, JuliaType::Any))
                        .map(|m| {
                            let type_name = m.params[0].1.to_string();
                            (m.global_index, type_name)
                        })
                        .collect();

                    if !candidates.is_empty() {
                        // Use CallDynamic for runtime dispatch
                        self.emit(Instr::CallDynamic(
                            method.global_index,
                            args.len(),
                            candidates,
                        ));
                    } else {
                        // No specific candidates, use static dispatch (with Lazy AoT check)
                        self.emit_call_or_specialize(function, method.global_index, args.len());
                    }
                } else if has_any_arg && has_multiple_methods && args.len() > 1 && {
                    // Issue #2480: Multi-arg runtime dispatch when any argument type is unknown.
                    // Case 1: Matched method has concrete (non-Any) params for Any-typed positions.
                    // E.g., div(Int32(5), r) where r is Any → matched div(::Int32, ::Int32).
                    // The concrete ::Int32 param for the Any position means the match may be wrong
                    // at runtime (r could be Rational{Int32}), so use runtime dispatch.
                    let case1 = arg_types.iter().zip(method.params.iter()).any(
                        |(arg_ty, (_, param_ty))| {
                            matches!(arg_ty, JuliaType::Any) && !matches!(param_ty, JuliaType::Any)
                        },
                    );
                    // Case 2 (Issue #2486): Matched method has Any params for Any-typed positions
                    // (e.g., rem(::Any, ::Any)), but there exist other methods with more specific
                    // params (e.g., rem(::Rational, ::Rational)). Runtime values may match
                    // those specific methods, so use runtime dispatch.
                    // Exclude when matched method has NO Any params at all (already specific).
                    let case2 = !case1 && {
                        let matched_all_any = method
                            .params
                            .iter()
                            .all(|(_, ty)| matches!(ty, JuliaType::Any));
                        matched_all_any
                            && table.methods.iter().any(|m| {
                                m.params.len() == args.len()
                                    && m.global_index != method.global_index
                                    && m.params.iter().any(|(_, ty)| !matches!(ty, JuliaType::Any))
                            })
                    };
                    case1 || case2
                } {
                    let candidates: Vec<(usize, Vec<String>)> = table
                        .methods
                        .iter()
                        .filter(|m| m.params.len() == args.len())
                        .map(|m| {
                            let type_names: Vec<String> = m
                                .params
                                .iter()
                                .map(|(_, ty)| match ty {
                                    JuliaType::TypeOf(inner) => inner.name().to_string(),
                                    _ => ty.name().to_string(),
                                })
                                .collect();
                            (m.global_index, type_names)
                        })
                        .collect();

                    if !candidates.is_empty() {
                        if candidates.len() == 1 {
                            self.emit_call_or_specialize(function, candidates[0].0, args.len());
                        } else {
                            let fallback_index = candidates[0].0;
                            self.emit(Instr::CallTypedDispatch(
                                function.to_string(),
                                args.len(),
                                fallback_index,
                                candidates,
                            ));
                        }
                    } else {
                        // No specific candidates, use static dispatch
                        self.emit_call_or_specialize(function, method.global_index, args.len());
                    }
                } else {
                    // No kwargs - use Call instruction (with Lazy AoT check)
                    self.emit_call_or_specialize(function, method.global_index, args.len());
                }
            } else {
                // Compile kwarg values (they go on stack after positional args)
                let kwarg_names: Vec<String> =
                    kwargs.iter().map(|(name, _)| name.clone()).collect();
                for (_, value) in kwargs {
                    // Infer type and compile value
                    let ty = self.compile_expr(value)?;
                    // For now, leave as is - VM will coerce if needed
                    let _ = ty;
                }
                // Emit CallWithKwargs or CallWithKwargsSplat instruction
                if has_kwargs_splat {
                    self.emit(Instr::CallWithKwargsSplat(
                        method.global_index,
                        args.len(),
                        kwarg_names,
                        kwargs_splat_mask.to_vec(),
                    ));
                } else {
                    self.emit(Instr::CallWithKwargs(
                        method.global_index,
                        args.len(),
                        kwarg_names,
                    ));
                }
            }
            // Override return type for functions known to return DataType or specific struct types
            let mut return_type = match function {
                "typeof" | "promote_type" | "promote_rule" | "eltype" | "keytype" | "valtype" => {
                    ValueType::DataType
                }
                // abs, abs2, sign: preserve argument type for BigInt and other numeric types
                // Issue #2383: abs(BigInt) should return BigInt, not Any
                "abs" | "abs2" | "sign" if args.len() == 1 => {
                    let arg_type = self.infer_expr_type(&args[0]);
                    match arg_type {
                        ValueType::BigInt => ValueType::BigInt,
                        ValueType::I128 => ValueType::I128,
                        ValueType::I64 => ValueType::I64,
                        ValueType::F32 => ValueType::F32,
                        ValueType::F16 => ValueType::F16,
                        // Complex abs returns F64 (magnitude), use method.return_type
                        _ => method.return_type.clone(),
                    }
                }
                // gcd, lcm: preserve BigInt type when arguments include BigInt
                // Issue #2383: gcd(BigInt, BigInt) should return BigInt, not Any
                "gcd" | "lcm" if args.len() == 2 => {
                    let has_bigint = args
                        .iter()
                        .any(|arg| matches!(self.infer_expr_type(arg), ValueType::BigInt));
                    if has_bigint {
                        ValueType::BigInt
                    } else {
                        // For I64 arguments, use method's return type
                        method.return_type.clone()
                    }
                }
                // typemin/typemax: return type matches the type argument
                // e.g., typemin(Float64) → F64, typemin(Int64) → I64
                "typemin" | "typemax" if args.len() == 1 => {
                    // Infer the type argument to determine the return type
                    let julia_ty = self.infer_julia_type(&args[0]);
                    match julia_ty {
                        JuliaType::TypeOf(inner) => match *inner {
                            JuliaType::Float64 => ValueType::F64,
                            JuliaType::Float32 => ValueType::F32,
                            JuliaType::Float16 => ValueType::F16,
                            JuliaType::Int64 => ValueType::I64,
                            JuliaType::Int32 => ValueType::I32,
                            JuliaType::Int16 => ValueType::I16,
                            JuliaType::Int8 => ValueType::I8,
                            JuliaType::Int128 => ValueType::I128,
                            JuliaType::UInt64 => ValueType::U64,
                            JuliaType::UInt32 => ValueType::U32,
                            JuliaType::UInt16 => ValueType::U16,
                            JuliaType::UInt8 => ValueType::U8,
                            JuliaType::UInt128 => ValueType::U128,
                            JuliaType::Bool => ValueType::Bool,
                            _ => method.return_type.clone(),
                        },
                        _ => method.return_type.clone(),
                    }
                }
                // HOF (Higher-Order Functions) - call-site specialization for better type inference
                "map" if args.len() == 2 => {
                    // map(f, arr) - infer return type based on f's return type
                    if let Some(ty) = self.infer_map_call_return_type(&args[0], &args[1]) {
                        ty
                    } else {
                        method.return_type.clone()
                    }
                }
                "filter" if args.len() == 2 => {
                    // filter(pred, arr) - return type has same element type as input
                    if let Some(ty) = self.infer_filter_call_return_type(&args[1]) {
                        ty
                    } else {
                        method.return_type.clone()
                    }
                }
                "reduce" | "foldl" if args.len() >= 2 => {
                    // reduce(op, itr) or reduce(op, itr, init)
                    // Return type is the element type of the iterator
                    if let Some(ty) = self.infer_reduce_call_return_type(&args[0], &args[1]) {
                        ty
                    } else {
                        method.return_type.clone()
                    }
                }
                "foldr" if args.len() >= 2 => {
                    // foldr(op, itr) - same as reduce for return type inference
                    if let Some(ty) = self.infer_reduce_call_return_type(&args[0], &args[1]) {
                        ty
                    } else {
                        method.return_type.clone()
                    }
                }
                // Iterator wrapper functions return specific struct types
                "enumerate" => {
                    // enumerate(iter) returns Enumerate{typeof(iter)}
                    // Instantiate Enumerate{Any} since we don't track the concrete type
                    self.shared_ctx
                        .resolve_instantiation("Enumerate", &[JuliaType::Any])
                        .map(ValueType::Struct)
                        .unwrap_or(method.return_type.clone())
                }
                "zip" => {
                    // zip returns Zip/Zip3/Zip4 depending on arity (Issue #1990)
                    let any_types: Vec<JuliaType> =
                        (0..args.len()).map(|_| JuliaType::Any).collect();
                    let struct_name = match args.len() {
                        3 => "Zip3",
                        4 => "Zip4",
                        _ => "Zip", // 2 args (default)
                    };
                    self.shared_ctx
                        .resolve_instantiation(struct_name, &any_types)
                        .map(ValueType::Struct)
                        .unwrap_or(method.return_type.clone())
                }
                "take" => {
                    // take(iter, n) returns Take{typeof(iter)}
                    // Instantiate Take{Any} since we don't track concrete inner type
                    self.shared_ctx
                        .resolve_instantiation("Take", &[JuliaType::Any])
                        .map(ValueType::Struct)
                        .unwrap_or(method.return_type.clone())
                }
                "drop" => {
                    // drop(iter, n) returns Drop{typeof(iter)}
                    // Instantiate Drop{Any} since we don't track concrete inner type
                    self.shared_ctx
                        .resolve_instantiation("Drop", &[JuliaType::Any])
                        .map(ValueType::Struct)
                        .unwrap_or(method.return_type.clone())
                }
                "iterate" => {
                    // iterate(collection) and iterate(collection, state) return (element, state) or nothing
                    // For compilation purposes, treat as Tuple to enable proper tuple indexing (y[2])
                    // This is safe because code should check `y === nothing` before accessing y[2]
                    ValueType::Tuple
                }
                _ => method.return_type.clone(),
            };

            if matches!(return_type, ValueType::Any) {
                let arg_value_types: Vec<ValueType> =
                    args.iter().map(|arg| self.infer_expr_type(arg)).collect();
                if !arg_value_types
                    .iter()
                    .any(|ty| matches!(ty, ValueType::Any))
                {
                    if let Some(func_ir) = self
                        .shared_ctx
                        .function_ir_by_global_index
                        .get(&method.global_index)
                    {
                        let inferred = infer_function_return_type_v2_with_arg_types(
                            func_ir,
                            &self.shared_ctx.struct_table,
                            &arg_value_types,
                        );
                        if !matches!(inferred, ValueType::Any) {
                            return_type = inferred;
                        }
                    }
                }
            }

            // Fix for parametric struct constructors: If return type is Any but this is actually
            // a struct constructor call (function name matches a struct in struct_table),
            // override the return type to the correct struct type.
            // This handles cases where the constructor was compiled and cached before the struct
            // was instantiated, causing it to have return type Any.
            if matches!(return_type, ValueType::Any) {
                // Extract base name (e.g., "Rational" from "Rational{T}")
                let base_name = if let Some(brace_pos) = function.find('{') {
                    &function[..brace_pos]
                } else {
                    function
                };

                // First, check if this matches any already-instantiated struct in struct_table
                let mut found_struct = false;
                for (name, struct_info) in self.shared_ctx.struct_table.iter() {
                    let struct_base = if let Some(pos) = name.find('{') {
                        &name[..pos]
                    } else {
                        name.as_str()
                    };

                    if struct_base == base_name {
                        // Found a matching struct - override return type
                        return_type = ValueType::Struct(struct_info.type_id);
                        found_struct = true;
                        break;
                    }
                }

                // If not found in struct_table, check if it's a parametric struct
                // that needs to be instantiated on demand
                if !found_struct && self.shared_ctx.parametric_structs.contains_key(base_name) {
                    // This is a parametric struct constructor that hasn't been instantiated yet
                    // Instantiate it with Any as the type parameter
                    match self
                        .shared_ctx
                        .resolve_instantiation(base_name, &[JuliaType::Any])
                    {
                        Ok(type_id) => {
                            return_type = ValueType::Struct(type_id);
                        }
                        Err(_) => {
                            // Failed to instantiate - keep Any
                        }
                    }
                }
            }

            Ok(return_type)
        } else {
            if self.usings.contains("Random") && is_random_function(function) {
                return self.compile_builtin(&BuiltinOp::Seed, args);
            }

            // Note: mean is now Pure Julia (stdlib/Statistics/src/Statistics.jl)
            // It's dispatched through the method table like other user-defined functions.

            // Handle n-arg reducible operators (+ and *) when there's no method table
            // This happens when flattening produces +(a, b, c, ...) with no user-defined +
            if is_reducible_nary_operator(function) && args.len() > 2 {
                // Reduce to chained binary ops using builtin operators
                return self.compile_nary_builtin_reduction(function, args);
            }

            // Try to map to BuiltinOp first (handles types properly)
            if let Some(builtin_op) = base_function_to_builtin_op(function) {
                return self.compile_builtin(&builtin_op, args);
            }
            // Fall back to string-based builtin call for functions not in BuiltinOp
            match self.compile_builtin_call(function, args) {
                Ok(ty) => Ok(ty),
                Err(CompileError::Msg(msg)) if msg.starts_with("Unknown function: ") => {
                    self.emit(Instr::PushStr(msg));
                    self.emit(Instr::ThrowError);
                    Ok(ValueType::Any)
                }
                Err(err) => Err(err),
            }
        }
    }

}
