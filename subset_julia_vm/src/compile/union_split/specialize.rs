//! Code specialization for union-split branches.
//!
//! This module provides functionality to generate specialized bytecode for
//! branches where types have been narrowed through union splitting.

use crate::compile::abstract_interp::TypeEnv;
use crate::compile::lattice::types::{ConcreteType, LatticeType};
use crate::ir::core::{BinaryOp, BuiltinOp, Expr, Stmt};
use crate::vm::instr::Instr;

/// Information about a specialized code path.
#[derive(Debug, Clone)]
pub struct SpecializedPath {
    /// The specialized type for this path
    pub specialized_type: ConcreteType,
    /// The type environment for this path
    pub env: TypeEnv,
    /// Generated bytecode instructions (placeholder for future work)
    pub instructions: Vec<Instr>,
}

/// Specialize a block of statements for a specific type.
///
/// This generates optimized bytecode knowing the exact type of variables,
/// enabling:
/// - Elimination of runtime type checks
/// - Use of specialized operations (e.g., specialized Int addition)
/// - Better optimization opportunities
///
/// # Arguments
///
/// * `block` - The statements to specialize
/// * `env` - The type environment with narrowed types
/// * `specialized_type` - The specific type this branch handles
///
/// # Returns
///
/// A vector of bytecode instructions (currently returns empty).
///
/// # Implementation Status
///
/// This function currently returns an empty instruction vector because full
/// implementation requires deep integration with the `Compiler` struct:
///
/// 1. **Compiler State Access**: The main compiler maintains local variable maps,
///    slot allocations, and type tracking that would need to be available here.
///
/// 2. **Method Table Lookups**: Specialized dispatch requires access to compiled
///    method tables to resolve the correct specialized method.
///
/// 3. **Instruction Selection**: Choosing between dynamic and specialized
///    instructions (e.g., `AddI64` vs `DynamicAdd`) requires type context.
///
/// 4. **Control Flow**: Generating correct jump offsets and label resolution
///    requires the full compilation context.
///
/// # Future Work
///
/// Full implementation would involve:
/// - Creating a specialized `Compiler` context with narrowed types
/// - Compiling each statement with type-specialized codegen
/// - Eliminating redundant type checks (isa calls that are always true/false)
/// - Using specialized intrinsics (AddI64 instead of DynamicAdd)
/// - Inlining small type-specific operations
///
/// # See Also
///
/// - `analyze_specialization_opportunities`: Identifies which optimizations apply
/// - `crate::compile::stmt::compile_stmt`: The main statement compilation logic
pub fn specialize_block(
    block: &[Stmt],
    env: &TypeEnv,
    specialized_type: &ConcreteType,
) -> Vec<Instr> {
    // Analyze opportunities for debugging/metrics purposes
    let _opportunities = analyze_specialization_opportunities(block, env, specialized_type);

    // Full bytecode generation requires Compiler context integration.
    // For now, return empty vector - the caller should fall back to
    // standard compilation with the specialized type environment.
    Vec::new()
}

/// Create a specialized path for a given type and environment.
///
/// This is a convenience function that packages the specialized type,
/// environment, and generated instructions together.
pub fn create_specialized_path(
    block: &[Stmt],
    env: TypeEnv,
    specialized_type: ConcreteType,
) -> SpecializedPath {
    let instructions = specialize_block(block, &env, &specialized_type);

    SpecializedPath {
        specialized_type,
        env,
        instructions,
    }
}

/// Optimization opportunities for specialized code.
///
/// This enum describes the types of optimizations that can be applied
/// when generating specialized code for a known type.
#[derive(Debug, Clone, PartialEq)]
pub enum SpecializationOpportunity {
    /// Eliminate a runtime `isa` check (always true/false)
    EliminateTypeCheck,
    /// Use specialized arithmetic (e.g., Int-specific add)
    SpecializedArithmetic,
    /// Use specialized array indexing (e.g., known element type)
    SpecializedArrayAccess,
    /// Inline type-specific operations
    InlineOperation,
    /// Eliminate boxing/unboxing for known types
    EliminateBoxing,
}

/// Analyze optimization opportunities for a specialized block.
///
/// This function identifies which optimizations can be applied when
/// compiling a block with narrowed type information.
///
/// # Arguments
///
/// * `block` - The statements to analyze
/// * `env` - The type environment with narrowed types
/// * `specialized_type` - The specific type this branch handles
///
/// # Returns
///
/// A vector of applicable optimization opportunities.
pub fn analyze_specialization_opportunities(
    block: &[Stmt],
    env: &TypeEnv,
    specialized_type: &ConcreteType,
) -> Vec<SpecializationOpportunity> {
    let mut opportunities = Vec::new();

    for stmt in block {
        analyze_stmt_opportunities(stmt, env, specialized_type, &mut opportunities);
    }

    opportunities
}

/// Analyze optimization opportunities in a single statement.
fn analyze_stmt_opportunities(
    stmt: &Stmt,
    env: &TypeEnv,
    specialized_type: &ConcreteType,
    opportunities: &mut Vec<SpecializationOpportunity>,
) {
    match stmt {
        Stmt::If {
            condition,
            then_branch,
            else_branch,
            ..
        } => {
            // Check if condition contains an `isa` check that's always true/false
            if is_eliminable_type_check(condition, env, specialized_type) {
                opportunities.push(SpecializationOpportunity::EliminateTypeCheck);
            }

            // Recursively analyze branches
            for s in &then_branch.stmts {
                analyze_stmt_opportunities(s, env, specialized_type, opportunities);
            }
            if let Some(else_block) = else_branch {
                for s in &else_block.stmts {
                    analyze_stmt_opportunities(s, env, specialized_type, opportunities);
                }
            }
        }

        Stmt::Assign { value, .. } | Stmt::AddAssign { value, .. } => {
            analyze_expr_opportunities(value, env, specialized_type, opportunities);
        }

        Stmt::For { body, .. }
        | Stmt::ForEach { body, .. }
        | Stmt::While { body, .. }
        | Stmt::TestSet { body, .. } => {
            for s in &body.stmts {
                analyze_stmt_opportunities(s, env, specialized_type, opportunities);
            }
        }

        Stmt::Return {
            value: Some(expr), ..
        } => {
            analyze_expr_opportunities(expr, env, specialized_type, opportunities);
        }

        Stmt::Expr { expr, .. } => {
            analyze_expr_opportunities(expr, env, specialized_type, opportunities);
        }

        Stmt::Block(block) => {
            for s in &block.stmts {
                analyze_stmt_opportunities(s, env, specialized_type, opportunities);
            }
        }

        _ => {}
    }
}

/// Analyze optimization opportunities in an expression.
fn analyze_expr_opportunities(
    expr: &Expr,
    env: &TypeEnv,
    specialized_type: &ConcreteType,
    opportunities: &mut Vec<SpecializationOpportunity>,
) {
    match expr {
        Expr::BinaryOp {
            left, right, op, ..
        } => {
            // Check if this is arithmetic on known numeric types
            if is_specializable_arithmetic(op, left, right, env, specialized_type) {
                opportunities.push(SpecializationOpportunity::SpecializedArithmetic);
            }

            // Recurse
            analyze_expr_opportunities(left, env, specialized_type, opportunities);
            analyze_expr_opportunities(right, env, specialized_type, opportunities);
        }

        Expr::Index { array, indices, .. } => {
            // Check if array indexing can be optimized
            if can_specialize_array_access(array, env, specialized_type) {
                opportunities.push(SpecializationOpportunity::SpecializedArrayAccess);
            }

            analyze_expr_opportunities(array, env, specialized_type, opportunities);
            for idx in indices {
                analyze_expr_opportunities(idx, env, specialized_type, opportunities);
            }
        }

        Expr::Call { args, .. } => {
            // Check if the call can be inlined for known types
            if can_inline_for_type(specialized_type) {
                opportunities.push(SpecializationOpportunity::InlineOperation);
            }

            for arg in args {
                analyze_expr_opportunities(arg, env, specialized_type, opportunities);
            }
        }

        Expr::Builtin { name, args, .. } => {
            // Check for eliminable isa checks
            if matches!(name, BuiltinOp::Isa)
                && args.len() == 2
                && is_eliminable_isa_check(&args[0], &args[1], env, specialized_type)
            {
                opportunities.push(SpecializationOpportunity::EliminateTypeCheck);
            }

            for arg in args {
                analyze_expr_opportunities(arg, env, specialized_type, opportunities);
            }
        }

        _ => {}
    }
}

/// Check if a condition contains a type check that's always true or false.
fn is_eliminable_type_check(
    condition: &Expr,
    env: &TypeEnv,
    specialized_type: &ConcreteType,
) -> bool {
    match condition {
        Expr::Builtin {
            name: BuiltinOp::Isa,
            args,
            ..
        } if args.len() == 2 => is_eliminable_isa_check(&args[0], &args[1], env, specialized_type),
        _ => false,
    }
}

/// Check if an isa check can be eliminated because we know the type.
fn is_eliminable_isa_check(
    var_expr: &Expr,
    _type_expr: &Expr,
    env: &TypeEnv,
    specialized_type: &ConcreteType,
) -> bool {
    if let Expr::Var(var_name, _) = var_expr {
        if let Some(var_type) = env.get(var_name) {
            // If the variable's type in the environment matches the specialized type,
            // the isa check result is statically known
            return get_concrete_type(var_type) == Some(specialized_type.clone());
        }
    }
    false
}

/// Extract a concrete type from a LatticeType if possible.
fn get_concrete_type(ty: &LatticeType) -> Option<ConcreteType> {
    match ty {
        LatticeType::Concrete(ct) => Some(ct.clone()),
        LatticeType::Const(cv) => Some(cv.to_concrete_type()),
        _ => None,
    }
}

/// Check if arithmetic can be specialized for numeric types.
fn is_specializable_arithmetic(
    op: &BinaryOp,
    left: &Expr,
    right: &Expr,
    env: &TypeEnv,
    specialized_type: &ConcreteType,
) -> bool {
    // Check if this is an arithmetic operation
    let is_arithmetic = matches!(
        op,
        BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Div | BinaryOp::Mod
    );

    if !is_arithmetic {
        return false;
    }

    // Check if the operands involve the specialized type
    let left_is_specialized = expr_uses_specialized_type(left, env, specialized_type);
    let right_is_specialized = expr_uses_specialized_type(right, env, specialized_type);

    // At least one operand should be of the specialized type
    (left_is_specialized || right_is_specialized) && is_numeric_type(specialized_type)
}

/// Check if an expression uses the specialized type.
fn expr_uses_specialized_type(expr: &Expr, env: &TypeEnv, specialized_type: &ConcreteType) -> bool {
    match expr {
        Expr::Var(name, _) => {
            if let Some(var_type) = env.get(name) {
                return get_concrete_type(var_type) == Some(specialized_type.clone());
            }
            false
        }
        _ => false,
    }
}

/// Check if array access can be specialized.
fn can_specialize_array_access(
    object: &Expr,
    env: &TypeEnv,
    specialized_type: &ConcreteType,
) -> bool {
    if let Expr::Var(name, _) = object {
        if let Some(var_type) = env.get(name) {
            // Check if the variable has an array type with matching element type
            if let Some(ConcreteType::Array { element }) = get_concrete_type(var_type) {
                return *element == *specialized_type;
            }
        }
    }
    false
}

/// Check if operations can be inlined for the specialized type.
fn can_inline_for_type(specialized_type: &ConcreteType) -> bool {
    // Primitive types have well-known operations that can be inlined
    matches!(
        specialized_type,
        ConcreteType::Int64
            | ConcreteType::Float64
            | ConcreteType::Bool
            | ConcreteType::String
            | ConcreteType::Char
    )
}

/// Check if a type is numeric.
fn is_numeric_type(ty: &ConcreteType) -> bool {
    matches!(
        ty,
        ConcreteType::Int8
            | ConcreteType::Int16
            | ConcreteType::Int32
            | ConcreteType::Int64
            | ConcreteType::Int128
            | ConcreteType::UInt8
            | ConcreteType::UInt16
            | ConcreteType::UInt32
            | ConcreteType::UInt64
            | ConcreteType::UInt128
            | ConcreteType::Float32
            | ConcreteType::Float64
            | ConcreteType::BigInt
            | ConcreteType::BigFloat
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compile::lattice::types::LatticeType;
    use crate::ir::core::{Block, Literal};
    use crate::span::Span;

    fn dummy_span() -> Span {
        Span::new(0, 0, 0, 0, 0, 0)
    }

    #[test]
    fn test_create_specialized_path() {
        let env = TypeEnv::new();
        let specialized_type = ConcreteType::Int64;

        let block = vec![Stmt::Return {
            value: Some(Expr::Literal(Literal::Int(42), dummy_span())),
            span: dummy_span(),
        }];

        let path = create_specialized_path(&block, env.clone(), specialized_type.clone());

        assert_eq!(path.specialized_type, specialized_type);
        // Instructions are empty (requires Compiler context for full implementation)
        assert_eq!(path.instructions.len(), 0);
    }

    #[test]
    fn test_specialize_block_returns_empty() {
        let env = TypeEnv::new();
        let specialized_type = ConcreteType::String;

        let block = vec![Stmt::Return {
            value: Some(Expr::Literal(
                Literal::Str("hello".to_string()),
                dummy_span(),
            )),
            span: dummy_span(),
        }];

        let instructions = specialize_block(&block, &env, &specialized_type);

        // Returns empty - full codegen requires Compiler context
        assert_eq!(instructions.len(), 0);
    }

    #[test]
    fn test_analyze_arithmetic_opportunities() {
        let mut env = TypeEnv::new();
        env.set("x", LatticeType::Concrete(ConcreteType::Int64));
        let specialized_type = ConcreteType::Int64;

        // x + 1
        let block = vec![Stmt::Expr {
            expr: Expr::BinaryOp {
                op: BinaryOp::Add,
                left: Box::new(Expr::Var("x".to_string(), dummy_span())),
                right: Box::new(Expr::Literal(Literal::Int(1), dummy_span())),
                span: dummy_span(),
            },
            span: dummy_span(),
        }];

        let opportunities = analyze_specialization_opportunities(&block, &env, &specialized_type);

        // Should identify specialized arithmetic opportunity
        assert!(opportunities.contains(&SpecializationOpportunity::SpecializedArithmetic));
    }

    #[test]
    fn test_analyze_type_check_elimination() {
        let mut env = TypeEnv::new();
        env.set("x", LatticeType::Concrete(ConcreteType::Int64));
        let specialized_type = ConcreteType::Int64;

        // if isa(x, Int64) ... end
        let block = vec![Stmt::If {
            condition: Expr::Builtin {
                name: BuiltinOp::Isa,
                args: vec![
                    Expr::Var("x".to_string(), dummy_span()),
                    Expr::Var("Int64".to_string(), dummy_span()),
                ],
                span: dummy_span(),
            },
            then_branch: Block {
                stmts: vec![],
                span: dummy_span(),
            },
            else_branch: None,
            span: dummy_span(),
        }];

        let opportunities = analyze_specialization_opportunities(&block, &env, &specialized_type);

        // Should identify eliminable type check
        assert!(opportunities.contains(&SpecializationOpportunity::EliminateTypeCheck));
    }

    #[test]
    fn test_analyze_inlining_opportunity() {
        let mut env = TypeEnv::new();
        env.set("x", LatticeType::Concrete(ConcreteType::Int64));
        let specialized_type = ConcreteType::Int64;

        // f(x) where x is known to be Int64
        let block = vec![Stmt::Expr {
            expr: Expr::Call {
                function: "f".to_string(),
                args: vec![Expr::Var("x".to_string(), dummy_span())],
                kwargs: vec![],
                splat_mask: vec![],
                kwargs_splat_mask: vec![],
                span: dummy_span(),
            },
            span: dummy_span(),
        }];

        let opportunities = analyze_specialization_opportunities(&block, &env, &specialized_type);

        // Should identify inlining opportunity for primitive type
        assert!(opportunities.contains(&SpecializationOpportunity::InlineOperation));
    }

    #[test]
    fn test_analyze_nested_blocks() {
        let mut env = TypeEnv::new();
        env.set("x", LatticeType::Concrete(ConcreteType::Float64));
        let specialized_type = ConcreteType::Float64;

        // for i in 1:10
        //     x * 2.0
        // end
        let block = vec![Stmt::For {
            var: "i".to_string(),
            start: Expr::Literal(Literal::Int(1), dummy_span()),
            end: Expr::Literal(Literal::Int(10), dummy_span()),
            step: None,
            body: Block {
                stmts: vec![Stmt::Expr {
                    expr: Expr::BinaryOp {
                        op: BinaryOp::Mul,
                        left: Box::new(Expr::Var("x".to_string(), dummy_span())),
                        right: Box::new(Expr::Literal(Literal::Float(2.0), dummy_span())),
                        span: dummy_span(),
                    },
                    span: dummy_span(),
                }],
                span: dummy_span(),
            },
            span: dummy_span(),
        }];

        let opportunities = analyze_specialization_opportunities(&block, &env, &specialized_type);

        // Should find specialized arithmetic in nested loop body
        assert!(opportunities.contains(&SpecializationOpportunity::SpecializedArithmetic));
    }

    #[test]
    fn test_is_numeric_type() {
        assert!(is_numeric_type(&ConcreteType::Int64));
        assert!(is_numeric_type(&ConcreteType::Float64));
        assert!(is_numeric_type(&ConcreteType::Int32));
        assert!(is_numeric_type(&ConcreteType::BigInt));

        assert!(!is_numeric_type(&ConcreteType::String));
        assert!(!is_numeric_type(&ConcreteType::Bool));
        assert!(!is_numeric_type(&ConcreteType::Nothing));
    }
}
