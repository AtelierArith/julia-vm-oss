//! Runtime specialization engine for Lazy AoT compilation.
//!
//! This module provides the lightweight compiler that runs at first call
//! to generate specialized bytecode based on actual argument types (typeof(x)).
//!
//! ## Supported Statement Types
//!
//! The following statement types can be specialized:
//! - `Block` - Sequential statement blocks
//! - `Assign` - Variable assignment
//! - `AddAssign` - Addition assignment (+=)
//! - `For` - Numeric for loops
//! - `ForEach` - Iteration loops (for x in iter)
//! - `While` - While loops
//! - `If` - Conditional branches
//! - `Break` / `Continue` - Loop control
//! - `Return` - Function return
//! - `Expr` - Expression statements
//!
//! ## Unsupported Statement Types (falls back to interpreter)
//!
//! - `Try` - Exception handling (requires complex control flow)
//! - `IndexAssign` - Array element assignment (high priority for future support)
//! - `FieldAssign` - Struct field assignment
//! - `DestructuringAssign` - Tuple/array destructuring
//! - `DictAssign` - Dictionary assignment
//! - `FunctionDef` - Nested function definitions
//! - `Test*` - Test framework macros
//! - `Label` / `Goto` - Jump labels (rarely used)
//!
//! ## Supported Expression Types
//!
//! - `Literal` - Int, Float, Bool, String, Nothing, Missing
//! - `Var` - Variable references
//! - `BinaryOp` - Binary operations (+, -, *, /, etc.)
//! - `UnaryOp` - Unary operations (-, !, etc.)
//! - `Call` - Function calls (including operators as functions)
//! - `Builtin` - Builtin function calls
//! - `ArrayLiteral` - Array construction
//! - `Index` - Array/tuple indexing
//! - `TupleLiteral` - Tuple construction
//! - `Range` - Range expressions (start:stop, start:step:stop)
//!
//! ## Error Messages
//!
//! When specialization fails for an unsupported construct, the error message
//! includes the readable variant name (e.g., "IndexAssign", "Try") rather than
//! an opaque discriminant. This is ensured by `stmt_variant_name()` and
//! `expr_variant_name()` which use exhaustive pattern matching - adding new
//! enum variants will cause a compiler error if these functions aren't updated.

use std::collections::HashMap;

use crate::ir::core::{Expr, Function, Literal};
use crate::vm::{Instr, ValueType};

mod expr;
mod helpers;
mod stmt;

#[cfg(test)]
use helpers::{expr_variant_name, stmt_variant_name};

/// Error during runtime specialization
#[derive(Debug, Clone)]
pub enum SpecializationError {
    /// Type mismatch between expected and actual
    TypeMismatch {
        expected: ValueType,
        actual: ValueType,
    },
    /// Compilation failed
    CompileFailed(String),
    /// Missing compile context
    MissingContext,
    /// Unsupported expression for specialization
    Unsupported(String),
}

impl std::fmt::Display for SpecializationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SpecializationError::TypeMismatch { expected, actual } => write!(
                f,
                "Type mismatch: expected {:?}, got {:?}",
                expected, actual
            ),
            SpecializationError::CompileFailed(msg) => {
                write!(f, "Specialization compile failed: {}", msg)
            }
            SpecializationError::MissingContext => write!(f, "Missing runtime compile context"),
            SpecializationError::Unsupported(msg) => write!(f, "Unsupported: {}", msg),
        }
    }
}

/// Result of specialization
#[derive(Debug)]
pub struct SpecializationResult {
    /// Generated bytecode
    pub code: Vec<Instr>,
    /// Inferred return type
    pub return_type: ValueType,
}

/// Specialize a function for specific argument types.
///
/// This is called at runtime when a function is first called with specific types.
/// The function is recompiled with those types fixed.
pub fn specialize_function(
    func: &Function,
    arg_types: &[ValueType],
) -> Result<SpecializationResult, SpecializationError> {
    // 1. Build locals map with fixed argument types
    let mut locals: HashMap<String, ValueType> = HashMap::new();
    for (param, ty) in func.params.iter().zip(arg_types.iter()) {
        locals.insert(param.name.clone(), ty.clone());
    }

    // 2. Create specializer
    let mut specializer = FunctionSpecializer::new(locals);

    // 3. Compile keyword parameter defaults and bind them as locals
    // Skip required kwargs (they don't have a valid default - marked with Literal::Undef)
    for kwparam in &func.kwparams {
        // Check if the kwparam is required (default is Undef)
        let is_required = matches!(&kwparam.default, Expr::Literal(Literal::Undef, _));
        if !is_required {
            let ty = specializer.compile_expr(&kwparam.default)?;
            specializer.locals.insert(kwparam.name.clone(), ty.clone());
            specializer.emit_store(&kwparam.name, ty);
        } else {
            // Required kwparam - use Any type (actual type determined at call site)
            specializer
                .locals
                .insert(kwparam.name.clone(), ValueType::Any);
        }
    }

    // 4. Compile the function body with implicit return handling
    //    In Julia, the last expression in a function is its return value.
    //    If the last statement is an if statement, each branch should return its value.
    specializer.compile_function_body(&func.body)?;

    let return_type = specializer.current_return_type.clone();

    Ok(SpecializationResult {
        code: specializer.code,
        return_type,
    })
}

/// Lightweight compiler for function specialization
struct FunctionSpecializer {
    code: Vec<Instr>,
    locals: HashMap<String, ValueType>,
    current_return_type: ValueType,
    /// Positions of break jumps to be patched
    break_positions: Vec<usize>,
    /// Positions of continue jumps to be patched
    continue_positions: Vec<usize>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::core::{BinaryOp, Block, Stmt};
    use crate::span::Span;
    use crate::vm::ArrayElementType;

    /// Helper to create a test span
    fn test_span() -> Span {
        Span::new(0, 0, 1, 1, 1, 1)
    }

    /// Verify that stmt_variant_name returns readable names for all statement types.
    /// This test ensures error messages are human-readable, not opaque discriminants.
    /// (Issue #2210, #2229)
    #[test]
    fn test_stmt_variant_name_returns_readable_names() {
        let span = test_span();

        // Test a representative sample of statement types
        let test_cases = vec![
            (
                Stmt::Block(Block {
                    stmts: vec![],
                    span,
                }),
                "Block",
            ),
            (
                Stmt::Assign {
                    var: "x".to_string(),
                    value: Expr::Literal(Literal::Int(1), span),
                    span,
                },
                "Assign",
            ),
            (
                Stmt::Try {
                    try_block: Block {
                        stmts: vec![],
                        span,
                    },
                    catch_var: Some("e".to_string()),
                    catch_block: Some(Block {
                        stmts: vec![],
                        span,
                    }),
                    else_block: None,
                    finally_block: None,
                    span,
                },
                "Try",
            ),
            (
                Stmt::IndexAssign {
                    array: "arr".to_string(),
                    indices: vec![],
                    value: Expr::Literal(Literal::Int(1), span),
                    span,
                },
                "IndexAssign",
            ),
            (
                Stmt::FieldAssign {
                    object: "obj".to_string(),
                    field: "x".to_string(),
                    value: Expr::Literal(Literal::Int(1), span),
                    span,
                },
                "FieldAssign",
            ),
        ];

        for (stmt, expected_name) in test_cases {
            let name = stmt_variant_name(&stmt);
            assert_eq!(
                name, expected_name,
                "stmt_variant_name should return '{}' for {:?}",
                expected_name, stmt
            );
            // Verify the name doesn't look like a discriminant
            assert!(
                !name.starts_with("Variant("),
                "stmt_variant_name should not return discriminant format: {}",
                name
            );
        }
    }

    /// Verify that expr_variant_name returns readable names for all expression types.
    /// (Issue #2210, #2229)
    #[test]
    fn test_expr_variant_name_returns_readable_names() {
        let span = test_span();

        let test_cases = vec![
            (Expr::Literal(Literal::Int(42), span), "Literal"),
            (Expr::Var("x".to_string(), span), "Var"),
            (
                Expr::BinaryOp {
                    op: BinaryOp::Add,
                    left: Box::new(Expr::Literal(Literal::Int(1), span)),
                    right: Box::new(Expr::Literal(Literal::Int(2), span)),
                    span,
                },
                "BinaryOp",
            ),
            (
                Expr::Index {
                    array: Box::new(Expr::Var("arr".to_string(), span)),
                    indices: vec![],
                    span,
                },
                "Index",
            ),
            (
                Expr::Comprehension {
                    body: Box::new(Expr::Var("x".to_string(), span)),
                    var: "x".to_string(),
                    iter: Box::new(Expr::Var("iter".to_string(), span)),
                    filter: None,
                    span,
                },
                "Comprehension",
            ),
            (
                Expr::Generator {
                    body: Box::new(Expr::Var("x".to_string(), span)),
                    var: "x".to_string(),
                    iter: Box::new(Expr::Var("iter".to_string(), span)),
                    filter: None,
                    span,
                },
                "Generator",
            ),
        ];

        for (expr, expected_name) in test_cases {
            let name = expr_variant_name(&expr);
            assert_eq!(
                name, expected_name,
                "expr_variant_name should return '{}' for {:?}",
                expected_name, expr
            );
            // Verify the name doesn't look like a discriminant
            assert!(
                !name.starts_with("Variant("),
                "expr_variant_name should not return discriminant format: {}",
                name
            );
        }
    }

    /// Verify that error messages for unsupported constructs include readable type names.
    /// (Issue #2210, #2229)
    #[test]
    fn test_unsupported_error_messages_are_readable() {
        let span = test_span();

        // Create an unsupported statement (Try)
        let try_stmt = Stmt::Try {
            try_block: Block {
                stmts: vec![],
                span,
            },
            catch_var: Some("e".to_string()),
            catch_block: Some(Block {
                stmts: vec![],
                span,
            }),
            else_block: None,
            finally_block: None,
            span,
        };

        let mut specializer = FunctionSpecializer::new(HashMap::new());
        let result = specializer.compile_stmt(&try_stmt);

        // Verify the error message contains the readable name
        assert!(
            matches!(&result, Err(SpecializationError::Unsupported(_))),
            "Expected Unsupported error for Try statement, got {:?}",
            result
        );
        if let Err(SpecializationError::Unsupported(msg)) = result {
            assert!(
                msg.contains("Try"),
                "Error message should contain 'Try', got: {}",
                msg
            );
            assert!(
                !msg.contains("Variant("),
                "Error message should not contain discriminant format: {}",
                msg
            );
        }

        // Test unsupported expression (Comprehension)
        let comprehension = Expr::Comprehension {
            body: Box::new(Expr::Var("x".to_string(), span)),
            var: "x".to_string(),
            iter: Box::new(Expr::Var("iter".to_string(), span)),
            filter: None,
            span,
        };

        let result = specializer.compile_expr(&comprehension);
        assert!(
            matches!(&result, Err(SpecializationError::Unsupported(_))),
            "Expected Unsupported error for Comprehension expression, got {:?}",
            result
        );
        if let Err(SpecializationError::Unsupported(msg)) = result {
            assert!(
                msg.contains("Comprehension"),
                "Error message should contain 'Comprehension', got: {}",
                msg
            );
        }
    }

    #[test]
    fn test_compile_index_preserves_arrayof_element_type() {
        let span = test_span();
        let mut locals = HashMap::new();
        locals.insert("arr".to_string(), ValueType::ArrayOf(ArrayElementType::F64));
        let mut specializer = FunctionSpecializer::new(locals);

        let array_expr = Expr::Var("arr".to_string(), span);
        let indices = vec![Expr::Literal(Literal::Int(1), span)];
        let result = specializer
            .compile_index(&array_expr, &indices)
            .expect("compile index");

        assert_eq!(result, ValueType::F64);
    }
}
