//! Shared convert() implementation for the VM (Issue #2259).
//!
//! This module provides a single `convert_value` function used by both
//! `builtins_exec.rs` and `builtins_types.rs`, eliminating duplicated
//! match arms that previously diverged when new types were added.
//!
//! The convert handler supports all numeric types (Int8-Int128, UInt8-UInt128,
//! Float16, Float32, Float64, BigInt, BigFloat), String, and Bool.
//! When adding a new Value variant, only this file needs to be updated.
//!
//! Integer converters are generated by `define_integer_converter!` macro to
//! ensure all source Value variants are handled uniformly (Issue #2288).

#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
// This module performs explicit numeric type conversions (Julia `convert(T, x)`).
// All `as` casts here are intentional type coercions — sign loss/truncation is
// caught at runtime via InexactError checks in the caller.
#![allow(clippy::cast_sign_loss)]

use super::error::VmError;
use super::value::{RustBigFloat, RustBigInt, Value, BIGFLOAT_PRECISION};

/// Convert a Value to the target type specified by name.
///
/// Returns `Ok(value)` on success, `Err(VmError)` if conversion is not supported.
pub(crate) fn convert_value(type_name: &str, value: &Value) -> Result<Value, VmError> {
    // Abstract types: return the value unchanged (identity conversion).
    // This handles cases like convert(Number, x) or convert(Any, x) that arise
    // from promote/convert chains in generic Number-typed methods.
    if matches!(
        type_name,
        "Any" | "Number" | "Real" | "Integer" | "Signed" | "Unsigned" | "AbstractFloat"
    ) {
        return Ok(value.clone());
    }

    match type_name {
        "Float64" => convert_to_f64(value),
        "Float32" => convert_to_f32(value),
        "Float16" => convert_to_f16(value),
        "Int64" | "Int" => convert_to_i64(value),
        "Int128" => convert_to_i128(value),
        "Int32" => convert_to_i32(value),
        "Int16" => convert_to_i16(value),
        "Int8" => convert_to_i8(value),
        "UInt64" => convert_to_u64(value),
        "UInt128" => convert_to_u128(value),
        "UInt32" => convert_to_u32(value),
        "UInt16" => convert_to_u16(value),
        "UInt8" => convert_to_u8(value),
        "BigInt" => convert_to_bigint(value),
        "BigFloat" => convert_to_bigfloat(value),
        "String" => convert_to_string(value),
        "Bool" => convert_to_bool(value),
        _ => Err(VmError::TypeError(format!(
            "unsupported target type for convert: {}",
            type_name
        ))),
    }
}

/// Macro to generate integer type converter functions.
///
/// Each generated function converts any numeric Value variant to the target
/// integer type. This ensures all source types are handled uniformly —
/// adding a new source Value variant only requires updating this macro.
///
/// # Parameters
/// - `$fn_name`: Name of the generated function (e.g., `convert_to_i128`)
/// - `$rust_ty`: Rust primitive type (e.g., `i128`)
/// - `$variant`: Value enum variant (e.g., `I128`)
/// - `$julia_name`: Julia type name for error messages (e.g., `"Int128"`)
/// - `$bool_one`: The literal `1` value for the target type (e.g., `1i128`)
macro_rules! define_integer_converter {
    ($fn_name:ident, $rust_ty:ty, $variant:ident, $julia_name:expr, $bool_one:expr) => {
        fn $fn_name(value: &Value) -> Result<Value, VmError> {
            match value {
                Value::I8(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::I16(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::I32(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::I64(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::I128(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::U8(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::U16(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::U32(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::U64(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::U128(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::F64(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::F32(v) => Ok(Value::$variant(*v as $rust_ty)),
                Value::F16(v) => Ok(Value::$variant(v.to_f64() as $rust_ty)),
                Value::Bool(v) => Ok(Value::$variant(if *v { $bool_one } else { 0 as $rust_ty })),
                _ => Err(VmError::TypeError(format!(
                    concat!("cannot convert {:?} to ", $julia_name),
                    value
                ))),
            }
        }
    };
}

// Generate all integer converter functions from a single source of truth.
// To add a new integer type: add one line here + a dispatch arm in convert_value().
define_integer_converter!(convert_to_i8, i8, I8, "Int8", 1i8);
define_integer_converter!(convert_to_i16, i16, I16, "Int16", 1i16);
define_integer_converter!(convert_to_i32, i32, I32, "Int32", 1i32);
define_integer_converter!(convert_to_i64, i64, I64, "Int64", 1i64);
define_integer_converter!(convert_to_i128, i128, I128, "Int128", 1i128);
define_integer_converter!(convert_to_u8, u8, U8, "UInt8", 1u8);
define_integer_converter!(convert_to_u16, u16, U16, "UInt16", 1u16);
define_integer_converter!(convert_to_u32, u32, U32, "UInt32", 1u32);
define_integer_converter!(convert_to_u64, u64, U64, "UInt64", 1u64);
define_integer_converter!(convert_to_u128, u128, U128, "UInt128", 1u128);

/// Convert any numeric Value to Float64.
fn convert_to_f64(value: &Value) -> Result<Value, VmError> {
    match value {
        Value::I64(v) => Ok(Value::F64(*v as f64)),
        Value::F64(v) => Ok(Value::F64(*v)),
        Value::F32(v) => Ok(Value::F64(*v as f64)),
        Value::F16(v) => Ok(Value::F64(v.to_f64())),
        Value::I8(v) => Ok(Value::F64(*v as f64)),
        Value::I16(v) => Ok(Value::F64(*v as f64)),
        Value::I32(v) => Ok(Value::F64(*v as f64)),
        Value::I128(v) => Ok(Value::F64(*v as f64)),
        Value::U8(v) => Ok(Value::F64(*v as f64)),
        Value::U16(v) => Ok(Value::F64(*v as f64)),
        Value::U32(v) => Ok(Value::F64(*v as f64)),
        Value::U64(v) => Ok(Value::F64(*v as f64)),
        Value::U128(v) => Ok(Value::F64(*v as f64)),
        Value::Bool(v) => Ok(Value::F64(if *v { 1.0 } else { 0.0 })),
        Value::Str(s) => s
            .parse::<f64>()
            .map(Value::F64)
            .map_err(|_| VmError::TypeError(format!("cannot convert \"{}\" to Float64", s))),
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to Float64",
            value
        ))),
    }
}

/// Convert any numeric Value to Float32.
fn convert_to_f32(value: &Value) -> Result<Value, VmError> {
    match value {
        Value::I64(v) => Ok(Value::F32(*v as f32)),
        Value::F64(v) => Ok(Value::F32(*v as f32)),
        Value::F32(v) => Ok(Value::F32(*v)),
        Value::F16(v) => Ok(Value::F32(v.to_f64() as f32)),
        Value::I8(v) => Ok(Value::F32(*v as f32)),
        Value::I16(v) => Ok(Value::F32(*v as f32)),
        Value::I32(v) => Ok(Value::F32(*v as f32)),
        Value::I128(v) => Ok(Value::F32(*v as f32)),
        Value::U8(v) => Ok(Value::F32(*v as f32)),
        Value::U16(v) => Ok(Value::F32(*v as f32)),
        Value::U32(v) => Ok(Value::F32(*v as f32)),
        Value::U64(v) => Ok(Value::F32(*v as f32)),
        Value::U128(v) => Ok(Value::F32(*v as f32)),
        Value::Bool(v) => Ok(Value::F32(if *v { 1.0 } else { 0.0 })),
        Value::Str(s) => s
            .parse::<f32>()
            .map(Value::F32)
            .map_err(|_| VmError::TypeError(format!("cannot convert \"{}\" to Float32", s))),
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to Float32",
            value
        ))),
    }
}

/// Convert any numeric Value to Float16.
fn convert_to_f16(value: &Value) -> Result<Value, VmError> {
    use half::f16;
    match value {
        Value::F16(v) => Ok(Value::F16(*v)),
        Value::F64(v) => Ok(Value::F16(f16::from_f64(*v))),
        Value::F32(v) => Ok(Value::F16(f16::from_f32(*v))),
        Value::I64(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::I8(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::I16(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::I32(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::I128(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::U8(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::U16(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::U32(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::U64(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::U128(v) => Ok(Value::F16(f16::from_f64(*v as f64))),
        Value::Bool(v) => Ok(Value::F16(f16::from_f64(if *v { 1.0 } else { 0.0 }))),
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to Float16",
            value
        ))),
    }
}

/// Convert any numeric Value to BigInt.
fn convert_to_bigint(value: &Value) -> Result<Value, VmError> {
    match value {
        Value::BigInt(v) => Ok(Value::BigInt(v.clone())),
        Value::I64(v) => Ok(Value::BigInt(RustBigInt::from(*v))),
        Value::I128(v) => Ok(Value::BigInt(RustBigInt::from(*v))),
        Value::I8(v) => Ok(Value::BigInt(RustBigInt::from(*v as i64))),
        Value::I16(v) => Ok(Value::BigInt(RustBigInt::from(*v as i64))),
        Value::I32(v) => Ok(Value::BigInt(RustBigInt::from(*v as i64))),
        Value::U8(v) => Ok(Value::BigInt(RustBigInt::from(*v as u64))),
        Value::U16(v) => Ok(Value::BigInt(RustBigInt::from(*v as u64))),
        Value::U32(v) => Ok(Value::BigInt(RustBigInt::from(*v as u64))),
        Value::U64(v) => Ok(Value::BigInt(RustBigInt::from(*v))),
        Value::U128(v) => Ok(Value::BigInt(RustBigInt::from(*v))),
        Value::Bool(v) => Ok(Value::BigInt(RustBigInt::from(if *v {
            1i64
        } else {
            0i64
        }))),
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to BigInt",
            value
        ))),
    }
}

/// Convert any numeric Value to BigFloat.
fn convert_to_bigfloat(value: &Value) -> Result<Value, VmError> {
    match value {
        Value::BigFloat(v) => Ok(Value::BigFloat(v.clone())),
        Value::F64(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v,
            BIGFLOAT_PRECISION,
        ))),
        Value::F32(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::F16(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            v.to_f64(),
            BIGFLOAT_PRECISION,
        ))),
        Value::I64(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::I128(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::I8(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::I16(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::I32(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::U8(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::U16(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::U32(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::U64(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::U128(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            *v as f64,
            BIGFLOAT_PRECISION,
        ))),
        Value::Bool(v) => Ok(Value::BigFloat(RustBigFloat::from_f64(
            if *v { 1.0 } else { 0.0 },
            BIGFLOAT_PRECISION,
        ))),
        Value::BigInt(v) => {
            // Convert BigInt to BigFloat via f64 (lossy for very large values)
            use std::str::FromStr;
            let f = f64::from_str(&v.to_string()).unwrap_or(0.0);
            Ok(Value::BigFloat(RustBigFloat::from_f64(
                f,
                BIGFLOAT_PRECISION,
            )))
        }
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to BigFloat",
            value
        ))),
    }
}

/// Convert Value to String.
fn convert_to_string(value: &Value) -> Result<Value, VmError> {
    match value {
        Value::I64(v) => Ok(Value::Str(v.to_string())),
        Value::F64(v) => Ok(Value::Str(v.to_string())),
        Value::Str(s) => Ok(Value::Str(s.clone())),
        Value::Char(c) => Ok(Value::Str(c.to_string())),
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to String",
            value
        ))),
    }
}

/// Convert Value to Bool.
fn convert_to_bool(value: &Value) -> Result<Value, VmError> {
    match value {
        Value::Bool(v) => Ok(Value::Bool(*v)),
        Value::I64(v) => Ok(Value::Bool(*v != 0)),
        Value::F64(v) => Ok(Value::Bool(*v != 0.0)),
        _ => Err(VmError::TypeError(format!(
            "cannot convert {:?} to Bool",
            value
        ))),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Verify that convert_value handles all numeric Value variants for each target type.
    /// This prevents the recurring bug where new types are added but convert handlers
    /// are not updated (Issue #1786, #2249).
    #[test]
    fn test_convert_handler_completeness() {
        let test_values: Vec<Value> = vec![
            Value::I8(1),
            Value::I16(1),
            Value::I32(1),
            Value::I64(1),
            Value::I128(1),
            Value::U8(1),
            Value::U16(1),
            Value::U32(1),
            Value::U64(1),
            Value::U128(1),
            Value::F16(half::f16::from_f32(1.0)),
            Value::F32(1.0),
            Value::F64(1.0),
            Value::Bool(true),
        ];

        for target in [
            "Float64", "Float32", "Float16", "Int64", "Int128", "Int32", "Int16", "Int8", "UInt64",
            "UInt128", "UInt32", "UInt16", "UInt8",
        ] {
            for val in &test_values {
                let result = convert_value(target, val);
                assert!(
                    result.is_ok(),
                    "convert({}, {:?}) should succeed but got: {:?}",
                    target,
                    val,
                    result.err()
                );
            }
        }
    }

    /// Verify BigInt conversion from all numeric types (Issue #2492).
    #[test]
    fn test_convert_to_bigint() {
        let test_values: Vec<Value> = vec![
            Value::I8(42),
            Value::I16(42),
            Value::I32(42),
            Value::I64(42),
            Value::I128(42),
            Value::U8(42),
            Value::U16(42),
            Value::U32(42),
            Value::U64(42),
            Value::U128(42),
            Value::Bool(true),
        ];

        for val in &test_values {
            let result = convert_value("BigInt", val);
            assert!(
                result.is_ok(),
                "convert(BigInt, {:?}) should succeed but got: {:?}",
                val,
                result.err()
            );
            assert!(
                result.as_ref().is_ok_and(|v| v.is_bigint()),
                "convert(BigInt, {:?}) should return BigInt",
                val
            );
        }

        // BigInt identity conversion
        let big = Value::BigInt(RustBigInt::from(42i64));
        let result = convert_value("BigInt", &big);
        assert!(result.is_ok());
        assert!(result.as_ref().is_ok_and(|v| v.is_bigint()));
    }

    /// Verify BigFloat conversion from all numeric types (Issue #2492).
    #[test]
    fn test_convert_to_bigfloat() {
        let test_values: Vec<Value> = vec![
            Value::I64(42),
            Value::F64(std::f64::consts::PI),
            Value::F32(std::f32::consts::PI),
            Value::F16(half::f16::from_f32(std::f32::consts::PI)),
            Value::Bool(true),
        ];

        for val in &test_values {
            let result = convert_value("BigFloat", val);
            assert!(
                result.is_ok(),
                "convert(BigFloat, {:?}) should succeed but got: {:?}",
                val,
                result.err()
            );
            assert!(
                result.as_ref().is_ok_and(|v| v.is_bigfloat()),
                "convert(BigFloat, {:?}) should return BigFloat",
                val
            );
        }

        // BigFloat identity conversion
        let bf = Value::BigFloat(RustBigFloat::from_f64(
            std::f64::consts::PI,
            BIGFLOAT_PRECISION,
        ));
        let result = convert_value("BigFloat", &bf);
        assert!(result.is_ok());
        assert!(result.as_ref().is_ok_and(|v| v.is_bigfloat()));
    }

    /// Verify abstract type names return identity (Issue #2492).
    #[test]
    fn test_convert_abstract_types_identity() {
        let val = Value::I64(42);
        for abstract_type in &[
            "Any",
            "Number",
            "Real",
            "Integer",
            "Signed",
            "Unsigned",
            "AbstractFloat",
        ] {
            let result = convert_value(abstract_type, &val);
            assert!(
                result.is_ok(),
                "convert({}, I64(42)) should succeed (identity)",
                abstract_type
            );
        }
    }
}
