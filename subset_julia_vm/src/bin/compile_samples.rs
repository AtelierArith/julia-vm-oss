#![deny(clippy::expect_used)]
//! Compile Julia samples to IR JSON for web playground
//!
//! Usage: cargo run --bin compile_samples > web/samples_ir.js

use std::io::{self, Write};
use subset_julia_vm::lowering::Lowering;
use subset_julia_vm::parser::Parser;

fn main() {
    let samples = vec![
        ("Hello World", r#"println("Hello, World!")"#),
        (
            "Sum to N",
            r#"function sum_to_n(N)
    sum = 0
    for i in 1:N
        sum += i
    end
    sum
end

result = sum_to_n(100)
println("Sum 1 to 100 = ", result)"#,
        ),
        (
            "Factorial (Recursive)",
            r#"function factorial(n)
    if n <= 1
        return 1
    end
    n * factorial(n - 1)
end

result = factorial(10)
println("10! = ", result)"#,
        ),
        (
            "Fibonacci (Recursive)",
            r#"function fib(n)
    if n <= 1
        return n
    end
    fib(n - 1) + fib(n - 2)
end

result = fib(15)
println("fib(15) = ", result)"#,
        ),
        (
            "Estimate Pi (Monte Carlo)",
            r#"function estimate_pi(N)
    inside = 0
    for i in 1:N
        x = rand()
        y = rand()
        if x^2 + y^2 < 1.0
            inside += 1
        end
    end
    4.0 * inside / N
end

result = estimate_pi(10000)
println("Estimated Pi = ", result)"#,
        ),
        (
            "Dot Product",
            r#"function dot_product(a, b)
    sum = 0.0
    for i in 1:length(a)
        sum += a[i] * b[i]
    end
    sum
end

a = [1.0, 2.0, 3.0]
b = [4.0, 5.0, 6.0]
result = dot_product(a, b)
println("dot([1,2,3], [4,5,6]) = ", result)"#,
        ),
        (
            "GCD (Euclidean)",
            r#"function gcd(a, b)
    while b != 0
        r = a % b
        a = b
        b = r
    end
    a
end

result = gcd(48, 18)
println("gcd(48, 18) = ", result)"#,
        ),
        (
            "Prime Check",
            r#"function is_prime(n)
    if n < 2
        return false
    end
    for i in 2:n-1
        if n % i == 0
            return false
        end
    end
    true
end

println("is_prime(17) = ", is_prime(17))
println("is_prime(18) = ", is_prime(18))"#,
        ),
        (
            "Newton's Method (sqrt)",
            r#"function newton_sqrt(x)
    guess = x / 2.0
    for i in 1:20
        guess = (guess + x / guess) / 2.0
    end
    guess
end

result = newton_sqrt(2.0)
println("sqrt(2) = ", result)"#,
        ),
        (
            "Mandelbrot ASCII Art",
            r##"# Mandelbrot escape time algorithm
function mandelbrot_escape(c, maxiter)
    z = 0.0 + 0.0im
    for k in 1:maxiter
        if abs2(z) > 4.0
            return k
        end
        z = z^2 + c
    end
    return maxiter
end

# Compute grid of escape times
function mandelbrot_grid(width, height, maxiter)
    xmin = -2.0; xmax = 1.0
    ymin = -1.2; ymax = 1.2
    grid = zeros(height, width)

    for row in 1:height
        ci = ymax - (row - 1) * (ymax - ymin) / (height - 1)
        for col in 1:width
            cr = xmin + (col - 1) * (xmax - xmin) / (width - 1)
            c = cr + ci * im
            grid[row, col] = mandelbrot_escape(c, maxiter)
        end
    end
    grid
end

# ASCII visualization
@time grid = mandelbrot_grid(50, 25, 50)
println("Mandelbrot Set (50x25):")
for row in 1:25
    for col in 1:50
        n = grid[row, col]
        if n == 50
            print("#")
        elseif n > 25
            print("+")
        elseif n > 10
            print(".")
        else
            print(" ")
        end
    end
    println("")
end

println(grid[12, 25])"##,
        ),
    ];

    let mut out = io::stdout();
    writeln!(out, "// Auto-generated IR JSON for web playground samples").unwrap();
    writeln!(out, "// Generated by: cargo run --bin compile_samples").unwrap();
    writeln!(out, "export const samplesIR = [").unwrap();

    let mut parser = Parser::new().unwrap_or_else(|e| {
        eprintln!("Error: failed to create parser: {}", e);
        std::process::exit(1);
    });

    for (i, (name, code)) in samples.iter().enumerate() {
        match parser.parse(code) {
            Ok(outcome) => {
                let mut lowering = Lowering::new(code);
                match lowering.lower(outcome) {
                    Ok(program) => {
                        let ir_json = serde_json::to_string(&program).unwrap();
                        let escaped_code = code
                            .replace('\\', "\\\\")
                            .replace('`', "\\`")
                            .replace("${", "\\${");
                        writeln!(out, "  {{").unwrap();
                        writeln!(out, "    name: \"{}\",", name).unwrap();
                        writeln!(out, "    code: `{}`,", escaped_code).unwrap();
                        writeln!(out, "    ir: `{}`", ir_json).unwrap();
                        if i < samples.len() - 1 {
                            writeln!(out, "  }},").unwrap();
                        } else {
                            writeln!(out, "  }}").unwrap();
                        }
                    }
                    Err(e) => {
                        eprintln!("Lowering error for '{}': {:?}", name, e);
                    }
                }
            }
            Err(e) => {
                eprintln!("Parse error for '{}': {:?}", name, e);
            }
        }
    }

    writeln!(out, "];").unwrap();
}
